[
  {
    "objectID": "documentation/index.html",
    "href": "documentation/index.html",
    "title": "TileDB-CF Overview",
    "section": "",
    "text": "Warning\n\n\n\nThe TileDB-CF library is still under initial development and changes may not be backward compatible."
  },
  {
    "objectID": "documentation/index.html#about",
    "href": "documentation/index.html#about",
    "title": "TileDB-CF Overview",
    "section": "About",
    "text": "About\nTileDB-CF is a python package intended to aid in modeling and analyzing complex multi-dimensional data in TileDB. It currently contains the following components:\n\nCore: High-level API for common TileDB group and metadata actions, and a creator class for generating TileDB groups following the TileDB-CF Dataspace specification.\nNetCDF Engine: Support for creating a TileDB group or array from NetCDF data and copying the data into the new group or array.\nXarray Engine:\n\nBackend engine that can be used with xarray.open_dataset.\nSupport for creating a TileDB from an xarray dataset and copying the data into the new group."
  },
  {
    "objectID": "documentation/index.html#installation",
    "href": "documentation/index.html#installation",
    "title": "TileDB-CF Overview",
    "section": "Installation",
    "text": "Installation\nThis project is available from PyPI and may be installed with pip:\npip install tiledb-cf\nTileDB-CF contains optional features that will be enabled if the required python packages are included in the python environment. These include:\n\nnetCDF4: support for the NetCDF engine,\nxarray: support for the xarray engine,\nparallel: support for dask operations (used with the xarray engine),\ncomplete: all of the above packages,\ndocs: support for quartodoc and the example notebooks.\n\nTo install tiledb-cf with additional dependencies use:\npip install tiledb-cf[<optional dependecies>]\nFor example, to install TileDB-CF-Py and enable the xarray engine with dask support:\npip install 'tiledb-cf[xarray,parallel]'"
  },
  {
    "objectID": "documentation/index.html#tiledb-data-model",
    "href": "documentation/index.html#tiledb-data-model",
    "title": "TileDB-CF Overview",
    "section": "TileDB Data Model",
    "text": "TileDB Data Model\nTileDB is a powerful open-source engine for storing and accessing dense and sparse multi-dimensional arrays. A complete description of the TileDB data model can be found at the TileDB website.\nTileDB stores data as dense or sparse multi-dimensional arrays. The arrays can be grouped together in TileDB groups. A brief summary:\n\nGroup: A group is a TileDB object that stores metadata, arrays, and other groups. The groups use URIs to track members, so multiple groups can store the same assets.\nArray: A set of attributes and dimensions that can be queried together:\n\nDimensions: The dimensions along with their domains orient a multi-dimensional space of cells. A dimension is defined by its name, domain, and data type along with additional data that specifies data storage and compression. The dimension values is called the cell coordinates. There can be any number of dimensions in an array.\nAttributes: In each cell in the logical layout, TileDB stores a tuple comprised of any number of attributes, each of any data type (fixed- or variable-sized).\n\nMetadata: This is (typically small) key-value data associated with an array or a group.\nDimension labels (experimental): Dimension labels store either increasing of decreasing data in a one-dimensional TileDB array that can be used to indirectly query other dimensions."
  },
  {
    "objectID": "documentation/api/index.html",
    "href": "documentation/api/index.html",
    "title": "",
    "section": "",
    "text": "cf.create_group\nCreates a TileDB group with arrays at relative locations inside the group.\n\n\ncf.open_group_array\nOpens an array in a group either by specifying the name of the array or the name\n\n\ncf.ArrayMetadata\nClass for accessing array-related metadata from a TileDB metadata object.\n\n\ncf.AttrMetadata\nMetadata wrapper for accessing attribute metadata.\n\n\ncf.DimMetadata\nMetadata wrapper for accessing dimension metadata.\n\n\ncf.DataspaceCreator\nCreator for a group of arrays that satify the CF Dataspace Convention.\n\n\n\n\n\n\n\n\n\ncf.from_netcdf\nConverts a NetCDF input file to nested TileDB CF dataspaces.\n\n\ncf.NetCDF4ConverterEngine\nConverter for NetCDF to TileDB using netCDF4.\n\n\ncf.netcdf_engine.NetCDF4CoordToDimConverter\nConverter for a NetCDF variable/dimension pair to a TileDB dimension.\n\n\ncf.netcdf_engine.NetCDF4DimToDimConverter\nConverter for a NetCDF dimension to a TileDB dimension.\n\n\ncf.netcdf_engine.NetCDF4ScalarToDimConverter\nConverter for NetCDF scalar (empty) dimensions to a TileDB Dimension.\n\n\ncf.netcdf_engine.NetCDF4ArrayConverter\nConverter for a TileDB array from a collection of NetCDF variables.\n\n\ncf.netcdf_engine.NetCDF4DomainConverter\nConverter for NetCDF dimensions to a TileDB domain.\n\n\ncf.netcdf_engine.NetCDF4ToDimConverter\nConverter from NetCDF to a TileDB dimension in a :class:NetCDF4ArrayConverter\n\n\ncf.netcdf_engine.NetCDF4VarToAttrConverter\nConverter for a NetCDF variable to a TileDB attribute.\n\n\n\n\n\n\n\n\n\ncf.from_xarray\nCreates a TileDB group and copies all data from an xarray dataset.\n\n\ncf.create_group_from_xarray\nCreates a TileDB group and arrays from an xarray dataset.\n\n\ncf.copy_data_from_xarray\nCopies data from an xarray dataset to a TileDB group.\n\n\ncf.copy_metadata_from_xarray\nCopies metadata from an xarray dataset to a TileDB group."
  },
  {
    "objectID": "documentation/api/cf.from_netcdf.html",
    "href": "documentation/api/cf.from_netcdf.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.from_netcdf(input_file, output_uri, input_group_path='/', recursive=True, output_key=None, output_ctx=None, unlimited_dim_size=10000, dim_dtype=_DEFAULT_INDEX_DTYPE, tiles_by_var=None, tiles_by_dims=None, coords_to_dims=False, collect_attrs=True, unpack_vars=False, offsets_filters=None, attrs_filters=None, copy_metadata=True)\nConverts a NetCDF input file to nested TileDB CF dataspaces.\nSee :class:~tiledb.cf.NetCDF4ConverterEngine for more information on the backend converter engine used for the conversion.\nParameters: input_file: The input NetCDF file to generate the converter engine from. output_uri: The uniform resource identifier for the TileDB group to be created. input_group_path: The path to the NetCDF group to copy data from. Use '/' for the root group. recursive: If True, recursively convert groups in a NetCDF file. Otherwise, only convert group provided. output_key: If not None, encryption key to decrypt arrays. output_ctx: If not None, TileDB context wrapper for a TileDB storage manager. dim_dtype: The numpy dtype for the TileDB dimensions created from NetCDF dimensions. unlimited_dim_size: The size of the domain for TileDB dimensions created from unlimited NetCDF dimensions. dim_dtype: The numpy dtype for TileDB dimensions. tiles_by_var: A map from the name of a NetCDF variable to the tiles of the dimensions of the variable in the generated TileDB array. tiles_by_dims: A map from the name of NetCDF dimensions defining a variable to the tiles of those dimensions in the generated TileDB array. coords_to_dims: If True, convert the NetCDF coordinate variable into a TileDB dimension for sparse arrays. Otherwise, convert the coordinate dimension into a TileDB dimension and the coordinate variable into a TileDB attribute. collect_attrs: If True, store all attributes with the same dimensions in the same array. Otherwise, store each attribute in a scalar array. unpack_vars: Unpack NetCDF variables with NetCDF attributes scale_factor or add_offset using the transformation scale_factor * value +         unpack. offsets_filters: Default filters for all offsets for variable attributes and dimensions. attrs_filters: Default filters for all attributes. copy_metadata: If True copy NetCDF group and variable attributes to TileDB metadata. If False do not copy metadata."
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4ArrayConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4ArrayConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4ArrayConverter()\nConverter for a TileDB array from a collection of NetCDF variables.\nAttributes: cell_order: The order in which TileDB stores the cells on disk inside a tile. Valid values are: row-major (default) or C for row major; col-major or F for column major; or Hilbert for a Hilbert curve. tile_order: The order in which TileDB stores the tiles on disk. Valid values are: row-major or C (default) for row major; or col-major or F for column major. capacity: The number of cells in a data tile of a sparse fragment. offsets_filters: Filters for the offsets for variable length attributes or dimensions. attrs_filters: Default filters to use when adding an attribute to the array. allows_duplicates: Specifies if multiple values can be stored at the same coordinate. Only allowed for sparse arrays.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_var_to_attr_converter\nAdds a new variable to attribute converter to the array creator.\n\n\ncopy\nCopies data from a NetCDF group to a TileDB CF array.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4ArrayConverter.add_var_to_attr_converter(self, ncvar, name=None, dtype=None, fill=None, var=False, nullable=False, filters=None, unpack=False)\nAdds a new variable to attribute converter to the array creator.\nThe attribute’s ‘dataspace name’ (name after dropping the suffix .data or .index) be unique.\nParameters: ncvar: NetCDF variable to convert to a TileDB attribute. name: Name of the new attribute that will be added. If None, the name will be copied from the NetCDF variable. dtype: Numpy dtype of the new attribute. If None, the data type will be copied from the variable. fill: Fill value for unset cells. If None, the fill value will be copied from the NetCDF variable if it has a fill value. var: Specifies if the attribute is variable length (automatic for byte/strings). nullable: Specifies if the attribute is nullable using validity tiles. filters: Specifies compression filters for the attribute. If None, use array’s attrs_filters property. unpack: Unpack NetCDF data that has NetCDF attributes scale_factor or add_offset using the transformation scale_factor * value +         unpack.\n\n\n\ncf.netcdf_engine.NetCDF4ArrayConverter.copy(self, netcdf_group, tiledb_uri, tiledb_key=None, tiledb_ctx=None, tiledb_timestamp=None, assigned_dim_values=None, assigned_attr_values=None, copy_metadata=True)\nCopies data from a NetCDF group to a TileDB CF array.\nParameters: netcdf_group: The NetCDF group to copy data from. tiledb_uri: The TileDB array uri to copy data into. tiledb_key: If not None, the encryption key for the TileDB array. tiledb_ctx: If not None, the TileDB context wrapper for a TileDB storage manager to use when opening the TileDB array. tiledb_timestamp: If not None, the timestamp to write the TileDB data at. assigned_dim_values: Mapping from dimension name to value for dimensions that are not copied from the NetCDF group. assigned_attr_values: Mapping from attribute name to numpy array of values for attributes that are not copied from the NetCDF group."
  },
  {
    "objectID": "documentation/api/cf.create_group_from_xarray.html",
    "href": "documentation/api/cf.create_group_from_xarray.html",
    "title": "",
    "section": "",
    "text": "cf.xarray_engine.create_group_from_xarray(dataset, group_uri, *, config=None, ctx=None, append=False, encoding=None, unlimited_dims=None, skip_vars=None, copy_group_metadata=True, copy_variable_metadata=True)\nCreates a TileDB group and arrays from an xarray dataset.\nOptionally copies metadata as well.\nParameters: dataset: The xarray Dataset to write. group_uri: The URI to the TileDB group to create or append to. config: A TileDB config object to use for TileDB objects. ctx: A TileDB context object to use for TileDB operations. append: If true, add arrays to an existing TileDB Group. Otherwise, create a new TileDB group to add arrays to. encoding: A nested dictionary with variable names as keys and dictionaries of TileDB specific encodings as values. unlimited_dims: Set of dimensions to use the maximum dimension size for. Only used for variables in the dataset that do not have max_size encoding provided. skip_vars: A set of names of variables not to add to the TileDB group. copy_group_metadata: If true, copy xarray dataset metadata to the TileDB group. copy_variable_metadata: If true, copy xarray variable metadata to the TileDB arrays as TileDB attribute metadata."
  },
  {
    "objectID": "documentation/api/cf.ArrayMetadata.html",
    "href": "documentation/api/cf.ArrayMetadata.html",
    "title": "",
    "section": "",
    "text": "cf.core.ArrayMetadata()\nClass for accessing array-related metadata from a TileDB metadata object.\nThis class provides a way for accessing the TileDB array metadata that excludes attribute and dimension specific metadata.\nParameters: metadata (tiledb.Metadata): TileDB array metadata object for the desired array."
  },
  {
    "objectID": "documentation/api/cf.DimMetadata.html",
    "href": "documentation/api/cf.DimMetadata.html",
    "title": "",
    "section": "",
    "text": "cf.core.DimMetadata(self, metadata, dim)\nMetadata wrapper for accessing dimension metadata.\nThis class allows access to the metadata for a dimension stored in the metadata for a TileDB array.\nParameters: metadata (tiledb.Metadata): TileDB array metadata for the array containing the desired attribute. dim (str): Name or index of the arrary attribute being requested."
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4VarToAttrConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4VarToAttrConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4VarToAttrConverter(self, name, dtype, fill, var, nullable, filters, input_var_name, input_var_dtype, unpack, *, registry=None)\nConverter for a NetCDF variable to a TileDB attribute.\nAttributes: name: Name of the new attribute. dtype: Numpy dtype of the attribute. fill: Fill value for unset cells. var: Specifies if the attribute is variable length (automatic for byte/strings). nullable: Specifies if the attribute is nullable using validity tiles. filters: Specifies compression filters for the attribute. input_var_name: Name of the input NetCDF variable that will be converted. input_var_dtype: Numpy dtype of the input NetCDF variable.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy_metadata\nCopy the metadata data from NetCDF to TileDB.\n\n\nget_values\nReturns TileDB attribute values from a NetCDF group.\n\n\nhtml_summary\nReturns a string HTML summary of the :class:AttrCreator.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4VarToAttrConverter.copy_metadata(self, netcdf_group, tiledb_array)\nCopy the metadata data from NetCDF to TileDB.\nParameters: netcdf_group: NetCDF group to get the metadata items from. tiledb_array: TileDB array to copy the metadata items to.\n\n\n\ncf.netcdf_engine.NetCDF4VarToAttrConverter.get_values(self, netcdf_group, indexer)\nReturns TileDB attribute values from a NetCDF group.\nParameters: netcdf_group: NetCDF group to get the dimension values from. indexer: Slice to query the NetCDF variable on.\nReturns: The values needed to set an attribute in a TileDB array. If the array is sparse the values will be returned as an 1D array; otherwise, they will be returned as an ND array.\n\n\n\ncf.netcdf_engine.NetCDF4VarToAttrConverter.html_summary(self)\nReturns a string HTML summary of the :class:AttrCreator."
  },
  {
    "objectID": "documentation/api/cf.AttrMetadata.html",
    "href": "documentation/api/cf.AttrMetadata.html",
    "title": "",
    "section": "",
    "text": "cf.core.AttrMetadata(self, metadata, attr)\nMetadata wrapper for accessing attribute metadata.\nThis class allows access to the metadata for an attribute stored in the metadata for a TileDB array.\nParameters: metadata (tiledb.Metadata): TileDB array metadata for the array containing the desired attribute. attr (str): Name or index of the arrary attribute being requested."
  },
  {
    "objectID": "documentation/api/cf.copy_data_from_xarray.html",
    "href": "documentation/api/cf.copy_data_from_xarray.html",
    "title": "",
    "section": "",
    "text": "cf.xarray_engine.copy_data_from_xarray(dataset, group_uri, *, config=None, ctx=None, region=None, skip_vars=None, copy_group_metadata=False, copy_variable_metadata=False)\nCopies data from an xarray dataset to a TileDB group.\nOptionally copies metadata as well as variable data.\nParameters: dataset: The xarray Dataset to write. group_uri: The URI to the TileDB group to create or append to. config: A TileDB config object to use for TileDB objects. ctx: A TileDB context object to use for TileDB operations. region: A mapping from dimension names to integer slices that specify what regions in the TileDB arrays to write the data. Regions include the first value of the slice and exclude the final value. skip_vars: A set of names of variables not to copy to the TileDB group. copy_group_metadata: If true, copy xarray dataset metadata to the TileDB group. copy_variable_metadata: If true, copy xarray variable metadata to the TileDB arrays as TileDB attribute metadata."
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4ToDimConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4ToDimConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4ToDimConverter(self, base, *, tile=None, filters=None, max_fragment_length=None)\nConverter from NetCDF to a TileDB dimension in a :class:NetCDF4ArrayConverter using a :class:SharedDim for the base dimension.\nAttributes: tile: The tile size for the dimension. filters: Specifies compression filters for the dimension.\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_from_netcdf\nReturns True if the dimension is converted from a NetCDF variable or\n\n\nmax_fragment_length\nThe maximum number of elements to copy at a time. If None, there is no\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_fragment_indices\nReturns a sequence of slices for copying chunks of the dimension data for\n\n\nhtml_summary\nReturns a string HTML summary of the :class:NetCDF4ToDimConverter.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4ToDimConverter.get_fragment_indices(self, netcdf_group)\nReturns a sequence of slices for copying chunks of the dimension data for each TileDB fragment.\nParameters: netcdf_group: NetCDF group to copy the data from.\nReturns: A sequence of slices for copying chunks of the dimension data for each TileDB fragment.\n\n\n\ncf.netcdf_engine.NetCDF4ToDimConverter.html_summary(self)\nReturns a string HTML summary of the :class:NetCDF4ToDimConverter."
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4CoordToDimConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4CoordToDimConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4CoordToDimConverter(self, name, domain, dtype, input_dim_name, input_var_name, input_var_dtype, unpack, *, registry=None)\nConverter for a NetCDF variable/dimension pair to a TileDB dimension.\nAttributes: name: Name of the TileDB dimension. domain: The (inclusive) interval on which the dimension is valid. dtype: The numpy dtype of the values and domain of the dimension. input_dim_name: The name of input NetCDF dimension. input_var_name: The name of input NetCDF variable. input_var_dtype: The numpy dtype of the input NetCDF variable.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy_metadata\nCopy the metadata data from NetCDF to TileDB.\n\n\nget_query_size\nReturns the number of coordinates to copy from NetCDF to TileDB.\n\n\nget_values\nReturns the values of the NetCDF coordinate that is being copied, or\n\n\nhtml_input_summary\nReturns a HTML string summarizing the input for the dimension.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4CoordToDimConverter.copy_metadata(self, netcdf_group, tiledb_array)\nCopy the metadata data from NetCDF to TileDB.\nParameters: netcdf_group: NetCDF group to get the metadata items from. tiledb_array: TileDB array to copy the metadata items to.\n\n\n\ncf.netcdf_engine.NetCDF4CoordToDimConverter.get_query_size(self, netcdf_group)\nReturns the number of coordinates to copy from NetCDF to TileDB.\nParameters: netcdf_group: NetCDF group to copy the data from.\n\n\n\ncf.netcdf_engine.NetCDF4CoordToDimConverter.get_values(self, netcdf_group, sparse, indexer)\nReturns the values of the NetCDF coordinate that is being copied, or None if the coordinate is of size 0.\nParameters: netcdf_group: NetCDF group to get the coordinate values from. sparse: True if copying into a sparse array and False if copying into a dense array.\nReturns: The coordinate values needed for querying the TileDB dimension in the form a numpy array.\n\n\n\ncf.netcdf_engine.NetCDF4CoordToDimConverter.html_input_summary(self)\nReturns a HTML string summarizing the input for the dimension."
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4DomainConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4DomainConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4DomainConverter()\nConverter for NetCDF dimensions to a TileDB domain.\n\n\n\n\n\nName\nDescription\n\n\n\n\nmax_fragment_shape\nMaximum shape of a fragment when copying from NetCDF to TileDB.\n\n\nnetcdf_dims\nOrdered tuple of NetCDF dimension names for dimension converters.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_query_coordinates\nReturns the coordinates used to copy data from a NetCDF group.\n\n\ninject_dim_creator\nAdd an additional dimension into the domain of the array.\n\n\nremove_dim_creator\nRemoves a dimension creator from the array creator.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4DomainConverter.get_query_coordinates(self, netcdf_group, sparse, indexer, assigned_dim_values=None)\nReturns the coordinates used to copy data from a NetCDF group.\nParameters: netcdf_group: Group to query the data from. sparse: If True, return coordinates for a sparse write. If False, return coordinates for a dense write. assigned_dim_values: Values for any non-NetCDF dimensions.\n\n\n\ncf.netcdf_engine.NetCDF4DomainConverter.inject_dim_creator(self, dim_name, position, **dim_kwargs)\nAdd an additional dimension into the domain of the array.\nParameters: dim_name: Name of the shared dimension to add to the array’s domain. position: Position of the shared dimension. Negative values count backwards from the end of the new number of dimensions. dim_kwargs: Keyword arguments to pass to :class:NetCDF4ToDimConverter.\n\n\n\ncf.netcdf_engine.NetCDF4DomainConverter.remove_dim_creator(self, dim_id)\nRemoves a dimension creator from the array creator.\nParameters: dim_id: dimension index (int) or name (str)"
  },
  {
    "objectID": "documentation/api/cf.open_group_array.html",
    "href": "documentation/api/cf.open_group_array.html",
    "title": "",
    "section": "",
    "text": "cf.core.open_group_array(group, *, array=None, attr=None, **kwargs)\nOpens an array in a group either by specifying the name of the array or the name of an attribute in the array.\nIf only providing the attribute, there must be exactly one array in the group with an attribute with the requested name.\nParameters: array: If not None, the name of the array to open. Overrides attr if both are provided. attr: If not None, open the array that contains this attr. Attr must be in only one of the group arrays. **kwargs: Keyword arguments to pass to the tiledb.open method.\nReturns: tiledb.Array opened in the specified mode"
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4ScalarToDimConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4ScalarToDimConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4ScalarToDimConverter()\nConverter for NetCDF scalar (empty) dimensions to a TileDB Dimension.\nAttributes: name: Name of the TileDB dimension. domain: The (inclusive) interval on which the dimension is valid. dtype: The numpy dtype of the values and domain of the dimension.\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_query_size\nReturns the number of coordinates to copy from NetCDF to TileDB.\n\n\nget_values\nGet dimension values from a NetCDF group.\n\n\nhtml_input_summary\nReturns a string HTML summary.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4ScalarToDimConverter.get_query_size(self, netcdf_group)\nReturns the number of coordinates to copy from NetCDF to TileDB.\nParameters: netcdf_group: NetCDF group to copy the data from.\n\n\n\ncf.netcdf_engine.NetCDF4ScalarToDimConverter.get_values(self, netcdf_group, sparse, indexer)\nGet dimension values from a NetCDF group.\nParameters: netcdf_group: NetCDF group to get the dimension values from. sparse: True if copying into a sparse array and False if copying into a dense array.\nReturns: The coordinates needed for querying the create TileDB dimension in the form of a numpy array if sparse is True and a slice otherwise.\n\n\n\ncf.netcdf_engine.NetCDF4ScalarToDimConverter.html_input_summary(self)\nReturns a string HTML summary."
  },
  {
    "objectID": "documentation/api/cf.from_xarray.html",
    "href": "documentation/api/cf.from_xarray.html",
    "title": "",
    "section": "",
    "text": "cf.xarray_engine.from_xarray(dataset, group_uri, *, config=None, ctx=None, encoding=None, region=None, unlimited_dims=None, skip_vars=None)\nCreates a TileDB group and copies all data from an xarray dataset.\nParameters: dataset: The xarray Dataset to write. group_uri: The URI to the TileDB group to create or append to. config: A TileDB config object to use for TileDB objects. ctx: A TileDB context object to use for TileDB operations. encoding: A nested dictionary with variable names as keys and dictionaries of TileDB specific encoding. encoding: A nested dictionary with variable names as keys and dictionaries of TileDB specific encodings as values. region: A mapping from dimension names to integer slices that specify what regions in the TileDB arrays to write the data. Regions include the first value of the slice and exclude the final value. unlimited_dims: Set of dimensions to use the maximum dimension size for. Only used for variables in the dataset that do not have max_size encoding provided. skip_vars: A set of names of variables not to add to the TileDB group."
  },
  {
    "objectID": "documentation/api/cf.create_group.html",
    "href": "documentation/api/cf.create_group.html",
    "title": "",
    "section": "",
    "text": "cf.core.create_group(uri, group_schema, *, key=None, ctx=None, config=None, append=False)\nCreates a TileDB group with arrays at relative locations inside the group.\nAll arrays in the group will be added at a relative URI that matches the array name.\nParameters: uri: Uniform resource identifier for TileDB group or array. group_schema: A mapping from array names to array schemas to add to the group. ctx: If not None, TileDB context wrapper for a TileDB storage manager. append: If True, add arrays from the provided group schema to an already existing group. The names for the arrays in the group schema cannot already exist in the group being append to."
  },
  {
    "objectID": "documentation/api/cf.DataspaceCreator.html",
    "href": "documentation/api/cf.DataspaceCreator.html",
    "title": "",
    "section": "",
    "text": "cf.core.DataspaceCreator(self)\nCreator for a group of arrays that satify the CF Dataspace Convention.\nThis class can be used directly to create a TileDB group that follows the TileDB CF Dataspace convention. It is also useful as a super class for converters/ingesters of data from sources that follow a NetCDF or NetCDF-like data model to TileDB.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_array_creator\nAdds a new array to the CF dataspace.\n\n\nadd_attr_creator\nAdds a new attribute to an array in the CF dataspace.\n\n\nadd_shared_dim\nAdds a new dimension to the CF dataspace.\n\n\narray_creators\nIterates over array creators in the CF dataspace.\n\n\ncreate_array\nCreates a TileDB array for a CF dataspace with only one array.\n\n\ncreate_group\nCreates a TileDB group and arrays for the CF dataspace.\n\n\nget_array_creator\nReturns the array creator with the requested name.\n\n\nget_array_creator_by_attr\nReturns the array creator with the requested attribute in it.\n\n\nget_shared_dim\nReturns the shared dimension with the requested name.\n\n\nremove_array_creator\nRemoves the specified array and all its attributes from the CF dataspace.\n\n\nremove_attr_creator\nRemoves the specified attribute from the CF dataspace.\n\n\nremove_shared_dim\nRemoves the specified dimension from the CF dataspace.\n\n\nshared_dims\nIterators over shared dimensions in the CF dataspace.\n\n\nto_schema\nReturns a dictionary of array schemas for the CF dataspace.\n\n\n\n\n\ncf.DataspaceCreator.add_array_creator(self, array_name, dims, cell_order='row-major', tile_order='row-major', capacity=0, tiles=None, dim_filters=None, offsets_filters=None, attrs_filters=None, allows_duplicates=False, sparse=False)\nAdds a new array to the CF dataspace.\nThe name of each array must be unique. All other properties should satisfy the same requirements as a tiledb.ArraySchema.\nParameters: array_name: Name of the new array to be created. dims: An ordered list of the names of the shared dimensions for the domain of this array. cell_order: The order in which TileDB stores the cells on disk inside a tile. Valid values are: row-major (default) or C for row major; col-major or F for column major; or Hilbert for a Hilbert curve. tile_order: The order in which TileDB stores the tiles on disk. Valid values are: row-major or C (default) for row major; or col-major or F for column major. capacity: The number of cells in a data tile of a sparse fragment. tiles: An optional ordered list of tile sizes for the dimensions of the array. The length must match the number of dimensions in the array. dim_filters: A dict from dimension name to a :class:tiledb.FilterList for dimensions in the array. offsets_filters: Filters for the offsets for variable length attributes or dimensions. attrs_filters: Default filters to use when adding an attribute to the array. allows_duplicates: Specifies if multiple values can be stored at the same coordinate. Only allowed for sparse arrays. sparse: Specifies if the array is a sparse TileDB array (true) or dense TileDB array (false).\n\n\n\ncf.DataspaceCreator.add_attr_creator(self, attr_name, array_name, dtype, fill=None, var=False, nullable=False, filters=None)\nAdds a new attribute to an array in the CF dataspace.\nThe ‘dataspace name’ (name after dropping the suffix .data or .index) must be unique.\nParameters: attr_name: Name of the new attribute that will be added. array_name: Name of the array the attribute will be added to. dtype: Numpy dtype of the new attribute. fill: Fill value for unset cells. var: Specifies if the attribute is variable length (automatic for byte/strings). nullable: Specifies if the attribute is nullable using validity tiles. filters: Specifies compression filters for the attribute.\n\n\n\ncf.DataspaceCreator.add_shared_dim(self, dim_name, domain, dtype)\nAdds a new dimension to the CF dataspace.\nEach dimension name must be unique. Adding a dimension where the name, domain, and dtype matches a current dimension does nothing.\nParameters: dim_name: Name of the new dimension to be created. domain: The (inclusive) interval on which the dimension is valid. dtype: The numpy dtype of the values and domain of the dimension.\n\n\n\ncf.DataspaceCreator.array_creators(self)\nIterates over array creators in the CF dataspace.\n\n\n\ncf.DataspaceCreator.create_array(self, uri, key=None, ctx=None)\nCreates a TileDB array for a CF dataspace with only one array.\nParameters: uri: Uniform resource identifier for the TileDB array to be created. key: If not None, encryption key to decrypt the array. ctx: If not None, TileDB context wrapper for a TileDB storage manager.\n\n\n\ncf.DataspaceCreator.create_group(self, uri, key=None, ctx=None, append=False)\nCreates a TileDB group and arrays for the CF dataspace.\nParameters: uri: Uniform resource identifier for the TileDB group to be created. key: If not None, encryption key, or dictionary of encryption keys, to decrypt arrays. ctx: If not None, TileDB context wrapper for a TileDB storage manager. append: If True, add arrays in the dataspace to an already existing group. The arrays in the dataspace cannot be in the group that is being append to.\n\n\n\ncf.DataspaceCreator.get_array_creator(self, array_name)\nReturns the array creator with the requested name.\nParameters: array_name: Name of the array to return.\n\n\n\ncf.DataspaceCreator.get_array_creator_by_attr(self, attr_name)\nReturns the array creator with the requested attribute in it.\nParameters: attr_name: Name of the attribute to return the array creator with.\n\n\n\ncf.DataspaceCreator.get_shared_dim(self, dim_name)\nReturns the shared dimension with the requested name.\nParameters: array_name: Name of the array to return.\n\n\n\ncf.DataspaceCreator.remove_array_creator(self, array_name)\nRemoves the specified array and all its attributes from the CF dataspace.\nParameters: array_name: Name of the array that will be removed.\n\n\n\ncf.DataspaceCreator.remove_attr_creator(self, attr_name)\nRemoves the specified attribute from the CF dataspace.\nParameters: attr_name: Name of the attribute that will be removed.\n\n\n\ncf.DataspaceCreator.remove_shared_dim(self, dim_name)\nRemoves the specified dimension from the CF dataspace.\nThis can only be used to remove dimensions that are not currently being used in an array.\nParameters: dim_name: Name of the dimension to be removed.\n\n\n\ncf.DataspaceCreator.shared_dims(self)\nIterators over shared dimensions in the CF dataspace.\n\n\n\ncf.DataspaceCreator.to_schema(self, ctx=None)\nReturns a dictionary of array schemas for the CF dataspace.\nParameters: ctx: If not None, TileDB context wrapper for a TileDB storage manager."
  },
  {
    "objectID": "documentation/api/cf.copy_metadata_from_xarray.html",
    "href": "documentation/api/cf.copy_metadata_from_xarray.html",
    "title": "",
    "section": "",
    "text": "cf.xarray_engine.copy_metadata_from_xarray(dataset, group_uri, *, config=None, ctx=None, skip_vars=None, copy_group_metadata=True, copy_variable_metadata=True)\nCopies metadata from an xarray dataset to a TileDB group.\nParameters: dataset: The xarray Dataset to write. group_uri: The URI to the TileDB group to create or append to. config: A TileDB config object to use for TileDB objects. ctx: A TileDB context object to use for TileDB operations. skip_vars: A set of names of variables not to copy to the group. copy_group_metadata: If true, copy xarray dataset metadata to the TileDB group. copy_variable_metadata: If true, copy xarray variable metadata to the TileDB arrays as TileDB attribute metadata."
  },
  {
    "objectID": "documentation/api/cf.NetCDF4ConverterEngine.html",
    "href": "documentation/api/cf.NetCDF4ConverterEngine.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4ConverterEngine(self, default_input_file=None, default_group_path=None)\nConverter for NetCDF to TileDB using netCDF4.\nThis class is used to generate and copy data to a TileDB group or array from a NetCDF file. The converter can be auto-generated from a NetCDF group, or it can be manually defined.\nThis is a subclass of :class:tiledb.cf.DataspaceCreator. See :class:tiledb.cf.DataspaceCreator for documentation of additional properties and methods.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_array_converter\nAdds a new NetCDF to TileDB array converter to the CF dataspace.\n\n\nadd_coord_to_dim_converter\nAdds a new NetCDF coordinate to TileDB dimension converter.\n\n\nadd_dim_to_dim_converter\nAdds a new NetCDF dimension to TileDB dimension converter.\n\n\nadd_scalar_to_dim_converter\nAdds a new TileDB dimension for NetCDF scalar variables.\n\n\nadd_var_to_attr_converter\nAdds a new variable to attribute converter to an array in the CF dataspace.\n\n\nconvert_to_array\nCreates a TileDB arrays for a CF dataspace with only one array and copies\n\n\nconvert_to_group\nCreates a TileDB group and its arrays from the defined CF dataspace and\n\n\ncopy_to_array\nCopies data from a NetCDF group to a TileDB array.\n\n\ncopy_to_group\nCopies data from a NetCDF group to a TileDB CF dataspace.\n\n\nfrom_file\nReturns a :class:NetCDF4ConverterEngine from a group in a NetCDF file.\n\n\nfrom_group\nReturns a :class:NetCDF4ConverterEngine from a :class:netCDF4.Group.\n\n\n\n\n\ncf.NetCDF4ConverterEngine.add_array_converter(self, array_name, dims, cell_order='row-major', tile_order='row-major', capacity=0, tiles=None, dim_filters=None, offsets_filters=None, attrs_filters=None, allows_duplicates=False, sparse=False)\nAdds a new NetCDF to TileDB array converter to the CF dataspace.\nThe name of each array must be unique. All properties must match the normal requirements for a TileDB.ArraySchema.\nParameters: array_name: Name of the new array to be created. dims: An ordered list of the names of the shared dimensions for the domain of this array. cell_order: The order in which TileDB stores the cells on disk inside a tile. Valid values are: row-major (default) or C for row major; col-major or F for column major; or Hilbert for a Hilbert curve. tile_order: The order in which TileDB stores the tiles on disk. Valid values are: row-major or C (default) for row major; or col-major or F for column major. capacity: The number of cells in a data tile of a sparse fragment. tiles: An optional ordered list of tile sizes for the dimensions of the array. The length must match the number of dimensions in the array. dim_filters: A dict from dimension name to a FilterList for dimensions in the array. offsets_filters: Filters for the offsets for variable length attributes or dimensions. attrs_filters: Default filters to use when adding an attribute to the array. allows_duplicates: Specifies if multiple values can be stored at the same coordinate. Only allowed for sparse arrays. sparse: Specifies if the array is a sparse TileDB array (true) or dense TileDB array (false).\n\n\n\ncf.NetCDF4ConverterEngine.add_coord_to_dim_converter(self, ncvar, dim_name=None, domain=None, dtype=None, unpack=False)\nAdds a new NetCDF coordinate to TileDB dimension converter.\nParameters: var: NetCDF coordinate variable to be converted. dim_name: If not None, name to use for the TileDB dimension. domain: If not None, the domain the TileDB dimension is valid on. dtype: If not None, the data type the TileDB dimension will be set to. unpack: Unpack NetCDF data that has NetCDF attributes scale_factor or add_offset using the transformation scale_factor * value +         unpack.\n\n\n\ncf.NetCDF4ConverterEngine.add_dim_to_dim_converter(self, ncdim, unlimited_dim_size=None, dtype=_DEFAULT_INDEX_DTYPE, dim_name=None)\nAdds a new NetCDF dimension to TileDB dimension converter.\nParameters: ncdim: NetCDF dimension to be converted. unlimited_dim_size: The size to use if the dimension is unlimited. If None, the current size of the NetCDF dimension will be used. dtype: Numpy type to use for the NetCDF dimension. dim_name: If not None, output name of the TileDB dimension.\n\n\n\ncf.NetCDF4ConverterEngine.add_scalar_to_dim_converter(self, dim_name='__scalars', dtype=_DEFAULT_INDEX_DTYPE)\nAdds a new TileDB dimension for NetCDF scalar variables.\nParameters: dim_name: Output name of the dimension. dtype: Numpy type to use for the scalar dimension\n\n\n\ncf.NetCDF4ConverterEngine.add_var_to_attr_converter(self, ncvar, array_name, attr_name=None, dtype=None, fill=None, var=False, nullable=False, filters=None, unpack=False)\nAdds a new variable to attribute converter to an array in the CF dataspace.\nThe attribute’s ‘dataspace name’ (name after dropping the suffix .data or .index) must be unique.\nParameters: ncvar: NetCDF variable to convert to a TileDB attribute. name: Name of the new attribute that will be added. If None, the name will be copied from the NetCDF variable. dtype: Numpy dtype of the new attribute. If None, the data type will be copied from the variable. fill: Fill value for unset cells. If None, the fill value will be copied from the NetCDF variable if it has a fill value. var: Specifies if the attribute is variable length (automatic for byte/strings). nullable: Specifies if the attribute is nullable using validity tiles. filters: Specifies compression filters for the attribute. unpack: Unpack NetCDF data that has NetCDF attributes scale_factor or add_offset using the transformation scale_factor * value +         unpack.\n\n\n\ncf.NetCDF4ConverterEngine.convert_to_array(self, output_uri, key=None, ctx=None, timestamp=None, input_netcdf_group=None, input_file=None, input_group_path=None, assigned_dim_values=None, assigned_attr_values=None, copy_metadata=True)\nCreates a TileDB arrays for a CF dataspace with only one array and copies data into it using the NetCDF converter engine.\nParameters: output_uri: Uniform resource identifier for the TileDB array to be created. key: If not None, encryption key to encrypt and decrypt output arrays. ctx: If not None, TileDB context wrapper for a TileDB storage manager. timestamp: If not None, the TileDB timestamp to write the NetCDF data to TileDB at. input_netcdf_group: If not None, the NetCDF group to copy data from. This will be prioritized over input_file if both are provided. input_file: If not None, the NetCDF file to copy data from. This will not be used if netcdf_group is not None. input_group_path: If not None, the path to the NetCDF group to copy data from. assigned_dim_values: Mapping from dimension name to value for dimensions that are not converter from the NetCDF group. assigned_attr_values: Mapping from attribute name to numpy array of values for attributes that are not converted from the NetCDF group. copy_metadata: If True copy NetCDF group and variable attributes to TileDB metadata. If False do not copy metadata.\n\n\n\ncf.NetCDF4ConverterEngine.convert_to_group(self, output_uri, key=None, ctx=None, timestamp=None, input_netcdf_group=None, input_file=None, input_group_path=None, assigned_dim_values=None, assigned_attr_values=None, copy_metadata=True, append=False)\nCreates a TileDB group and its arrays from the defined CF dataspace and copies data into them using the converter engine.\nParameters: output_uri: Uniform resource identifier for the TileDB group to be created. key: If not None, encryption key to encrypt and decrypt output arrays. ctx: If not None, TileDB context wrapper for a TileDB storage manager. timestamp: If not None, the TileDB timestamp to write the NetCDF data to TileDB at. input_netcdf_group: If not None, the NetCDF group to copy data from. This will be prioritized over input_file if both are provided. input_file: If not None, the NetCDF file to copy data from. This will not be used if netcdf_group is not None. input_group_path: If not None, the path to the NetCDF group to copy data from. assigned_dim_values: Mapping from dimension name to value for dimensions that are not converted from the NetCDF group. assigned_attr_values: Mapping from attribute name to numpy array of values for attributes that are not converted from the NetCDF group. copy_metadata: If True copy NetCDF group and variable attributes to TileDB metadata. If False do not copy metadata. append: If True, add arrays in the dataspace to an already existing group. The arrays in the dataspace cannot be in the group that is being append to.\n\n\n\ncf.NetCDF4ConverterEngine.copy_to_array(self, output_uri, key=None, ctx=None, timestamp=None, input_netcdf_group=None, input_file=None, input_group_path=None, assigned_dim_values=None, assigned_attr_values=None, copy_metadata=True)\nCopies data from a NetCDF group to a TileDB array.\nThis will copy data from a NetCDF group that is defined either by a :class:netCDF4.Group or by an input_file and group path. If neither the netcdf_group or input_file is specified, this will copy data from the input file self.default_input_file. If both netcdf_group and input_file are set, this method will prioritize using the NetCDF group set by netcdf_group.\nParameters: output_uri: Uniform resource identifier for the TileDB array data is being copied to. key: If not None, encryption key to decrypt arrays. ctx: If not None, TileDB context wrapper for a TileDB storage manager. timestamp: If not None, the TileDB timestamp to write the NetCDF data to TileDB at. input_netcdf_group: If not None, the NetCDF group to copy data from. This will be prioritized over input_file if both are provided. input_file: If not None, the NetCDF file to copy data from. This will not be used if netcdf_group is not None. input_group_path: If not None, the path to the NetCDF group to copy data from. assigned_dim_values: Mapping from dimension name to value for dimensions that are not copied from the NetCDF group. assigned_attr_values: Mapping from attribute name to numpy array of values for attributes that are not copied from the NetCDF group. copy_metadata: If True copy NetCDF group and variable attributes to TileDB metadata. If False do not copy metadata.\n\n\n\ncf.NetCDF4ConverterEngine.copy_to_group(self, output_uri, key=None, ctx=None, timestamp=None, input_netcdf_group=None, input_file=None, input_group_path=None, assigned_dim_values=None, assigned_attr_values=None, copy_metadata=True)\nCopies data from a NetCDF group to a TileDB CF dataspace.\nThis will copy data from a NetCDF group that is defined either by a :class:netCDF4.Group or by an input_file and group path. If neither the netcdf_group or input_file is specified, this will copy data from the input file self.default_input_file. If both netcdf_group and input_file are set, this method will prioritize using the NetCDF group set by netcdf_group.\nParameters: output_uri: Uniform resource identifier for the TileDB group data is being copied to. key: If not None, encryption key to decrypt arrays. ctx: If not None, TileDB context wrapper for a TileDB storage manager. timestamp: If not None, the TileDB timestamp to write the NetCDF data to TileDB at. input_netcdf_group: If not None, the NetCDF group to copy data from. This will be prioritized over input_file if both are provided. input_file: If not None, the NetCDF file to copy data from. This will not be used if netcdf_group is not None. input_group_path: If not None, the path to the NetCDF group to copy data from. assigned_dim_values: Mapping from dimension name to value for dimensions that are not copied from the NetCDF group. assigned_attr_values: Mapping from attribute name to numpy array of values for the attributes that are not copied from the NetCDF group. copy_metadata: If True copy NetCDF group and variable attributes to TileDB metadata. If False do not copy metadata.\n\n\n\ncf.NetCDF4ConverterEngine.from_file(cls, input_file, group_path='/', unlimited_dim_size=None, dim_dtype=_DEFAULT_INDEX_DTYPE, tiles_by_var=None, tiles_by_dims=None, coords_to_dims=False, collect_attrs=True, unpack_vars=False, offsets_filters=None, attrs_filters=None)\nReturns a :class:NetCDF4ConverterEngine from a group in a NetCDF file.\nParameters: input_file: The input NetCDF file to generate the converter engine from. group_path: The path to the NetCDF group to copy data from. Use '/' for the root group. unlimited_dim_size: The size of the domain for TileDB dimensions created from unlimited NetCDF dimensions. If None, the current size of the NetCDF dimension will be used. dim_dtype: The numpy dtype for TileDB dimensions. tiles_by_var: A map from the name of a NetCDF variable to the tiles of the dimensions of the variable in the generated TileDB array. tiles_by_dims: A map from the name of NetCDF dimensions defining a variable to the tiles of those dimensions in the generated TileDB array. coords_to_dims: If True, convert the NetCDF coordinate variable into a TileDB dimension for sparse arrays. Otherwise, convert the coordinate dimension into a TileDB dimension and the coordinate variable into a TileDB attribute. collect_attrs: If True, store all attributes with the same dimensions in the same array. Otherwise, store each attribute in a scalar array. unpack_vars: Unpack NetCDF variables with NetCDF attributes scale_factor or add_offset using the transformation scale_factor * value +         unpack. offsets_filters: Default filters for all offsets for variable attributes and dimensions. attrs_filters: Default filters for all attributes.\n\n\n\ncf.NetCDF4ConverterEngine.from_group(cls, netcdf_group, unlimited_dim_size=None, dim_dtype=_DEFAULT_INDEX_DTYPE, tiles_by_var=None, tiles_by_dims=None, coords_to_dims=False, collect_attrs=True, unpack_vars=False, offsets_filters=None, attrs_filters=None, default_input_file=None, default_group_path=None)\nReturns a :class:NetCDF4ConverterEngine from a :class:netCDF4.Group.\nParameters: group: The NetCDF group to convert. unlimited_dim_size: The size of the domain for TileDB dimensions created from unlimited NetCDF dimensions. If None, the current size of the NetCDF variable will be used. dim_dtype: The numpy dtype for TileDB dimensions. tiles_by_var: A map from the name of a NetCDF variable to the tiles of the dimensions of the variable in the generated TileDB array. tiles_by_dims: A map from the name of NetCDF dimensions defining a variable to the tiles of those dimensions in the generated TileDB array. coords_to_dims: If True, convert the NetCDF coordinate variable into a TileDB dimension for sparse arrays. Otherwise, convert the coordinate dimension into a TileDB dimension and the coordinate variable into a TileDB attribute. collect_attrs: If True, store all attributes with the same dimensions in the same array. Otherwise, store each attribute in a scalar array. unpack_vars: Unpack NetCDF variables with NetCDF attributes scale_factor or add_offset using the transformation scale_factor * value +         unpack. offsets_filters: Default filters for all offsets for variable attributes and dimensions. attrs_filters: Default filters for all attributes. default_input_file: If not None, the default NetCDF input file to copy data from. default_group_path: If not None, the default NetCDF group to copy data from. Use '/' to specify the root group."
  },
  {
    "objectID": "documentation/api/cf.netcdf_engine.NetCDF4DimToDimConverter.html",
    "href": "documentation/api/cf.netcdf_engine.NetCDF4DimToDimConverter.html",
    "title": "",
    "section": "",
    "text": "cf.netcdf_engine.NetCDF4DimToDimConverter(self, name, domain, dtype, input_dim_name, input_dim_size, is_unlimited, *, registry)\nConverter for a NetCDF dimension to a TileDB dimension.\nAttributes: name: Name of the TileDB dimension. domain: The (inclusive) interval on which the dimension is valid. dtype: The numpy dtype of the values and domain of the dimension. input_dim_name: Name of the input NetCDF variable. input_dim_size: Size of the input NetCDF variable. is_unlimited: If True, the input NetCDF variable is unlimited.\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_query_size\nReturns the number of coordinates to copy from NetCDF to TileDB.\n\n\nget_values\nReturns the values of the NetCDF dimension that is being copied.\n\n\nhtml_input_summary\nReturns a HTML string summarizing the input for the dimension.\n\n\n\n\n\ncf.netcdf_engine.NetCDF4DimToDimConverter.get_query_size(self, netcdf_group)\nReturns the number of coordinates to copy from NetCDF to TileDB.\nParameters: netcdf_group: NetCDF group to copy the data from.\n\n\n\ncf.netcdf_engine.NetCDF4DimToDimConverter.get_values(self, netcdf_group, sparse, indexer)\nReturns the values of the NetCDF dimension that is being copied.\nParameters: netcdf_group: NetCDF group to get the dimension values from. sparse: True if copying into a sparse array and False if copying into a dense array.\nReturns: The coordinates needed for querying the created TileDB dimension in the form of a numpy array if sparse is True and a slice otherwise.\n\n\n\ncf.netcdf_engine.NetCDF4DimToDimConverter.html_input_summary(self)\nReturns a HTML string summarizing the input for the dimension."
  },
  {
    "objectID": "documentation/code-of-conduct.html",
    "href": "documentation/code-of-conduct.html",
    "title": "TileDB-CF Code of Conduct",
    "section": "",
    "text": "All participants in TileDB spaces are expected to adhere to high standards of professionalism in all interactions. These standards include, but are not limited to, the specific behaviors outlined below. Upholding these standards is fundamental to our commitment to create a welcoming, positive, and inclusive environment for everyone. We as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n\nExamples of behavior that contributes to creating a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for the community\nShowing empathy towards other community members\n\nAll of these serve to help the make the project better, but also serve to make the experience of participating in the project better as well.\nExamples of unacceptable behavior by participants include:\n\nSexist, racist, and other exclusionary language\nThe use of sexualized language or imagery and unwelcome sexual attention or advances\nTrolling, insulting/derogatory comments, and personal or political attacks\nPublic or private harassment or intimidation\nPublishing others’ private information, such as a physical or electronic address, without explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting\n\n\n\n\nProject maintainers are responsible for maintaining, upholding, and observing these standards.\n\n\n\nPlease contact conduct@tiledb.com. All code of conduct reports will be kept in confidence.\n\n\n\nThis document is adapted from the Bokeh code of conduct, which is in turn adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4"
  },
  {
    "objectID": "documentation/contributing.html",
    "href": "documentation/contributing.html",
    "title": "Contributing to TileDB-CF-Py",
    "section": "",
    "text": "Thank you for your interest in contributing to TileDB-CF-Py. The following notes are intended to help you file issues, bug reports, or contribute code to this open source project."
  },
  {
    "objectID": "documentation/contributing.html#contributing-checklist",
    "href": "documentation/contributing.html#contributing-checklist",
    "title": "Contributing to TileDB-CF-Py",
    "section": "Contributing Checklist",
    "text": "Contributing Checklist\n\nReporting a bug? Please read how to file a bug report section to make sure sufficient information is included.\nContributing code? You rock! Be sure to review the contributor section for helpful tips on the tools we use to build this project, format code, and issue pull requests (PR)’s.\n\nNote: All participants in TileDB spaces are expected to adhere to a high standard of profectionalism in all interactions. See the code of conduct for more information."
  },
  {
    "objectID": "documentation/contributing.html#reporting-a-bug",
    "href": "documentation/contributing.html#reporting-a-bug",
    "title": "Contributing to TileDB-CF-Py",
    "section": "Reporting a Bug",
    "text": "Reporting a Bug\nA useful bug report filed as a GitHub issue provides information about how to reproduce the error.\n\nBefore opening a new GitHub issue try searching the existing issues to see if someone else has already noticed the same problem.\nWhen filing a bug report, provide where possible:\n\nThe version of TileDB-CF-Py or if a dev version, the specific commit that triggers the error.\nThe full error message, including the backtrace (if possible).\nA minimal working example, i.e. the smallest chunk of code that triggers the error. Ideally, this should be code that can be a small reduced python file. If the code to reproduce is somewhat long, consider putting it in a gist.\n\nWhen pasting code blocks or output, put triple backquotes (```) around the text so GitHub will format it nicely. Code statements should be surrounded by single backquotes (`). See GitHub’s guide on Markdown for more formatting tricks."
  },
  {
    "objectID": "documentation/contributing.html#contributing-code",
    "href": "documentation/contributing.html#contributing-code",
    "title": "Contributing to TileDB-CF-Py",
    "section": "Contributing Code",
    "text": "Contributing Code\nBy contributing code to TileDB-CF-Py, you are agreeing to release it under the MIT License.\n\nQuickstart Workflow\nFrom a fork of TileDB-CF-Py\ngit clone https://github.com/username/TileDB-CF-Py\npip install -e '.[parallel]'\ngit checkout -b <my_initials>/<my_bugfix/feature_branch>\n# ... code changes ...\n./tools/lint.sh # run linters\ngit commit -a -m \"descriptive commit message\"\ngit push --set-upstream origin <my_initials>/<my_bugfix_branch>\nIssue a PR from your updated TileDB-CF-Py fork\nBranch conventions:\n\ndev is the development branch of TileDB-CF-Py, all PR’s are merged into dev.\nrelease-x.y.z are major / bugfix release branches.\n\n\n\nBuilding Locally for Development\nThis project uses setuptools for its build system, and can be built locally using pip. It is recommended you set-up a Python virtual environment with your preferred method before installing. Once the virtual environment is activated, install tiledb.cf as ‘editable’ using pip:\npip install -e .\nThe following tools are used for testing, linting, and formatting. You may want to install them either in the local virtual environment or as command line tools for you system:\n\nblack\nflake8\nmypy\npytest (with pytest-cov)\n\n\n\nFormatting, Style, and Linting\n\n4 spaces per indentation level not tabs\nclass names use CamelCase\nmember functions, variables use snake_case\nprivate module or class member use a leading underscore _local_variable\ncomments are good, the project uses Google-style docstrings with type hints\nformat code using black and isort\nlint code using flake8 and mypy\n\nIt is highly recommended to run formatting and linting tools before every commit. This can be automated by activating the pre-commit hook tools/hooks/pre-commit.sh. To do this symlink or copy tools/hooks/pre-commit.sh to .git/hooks/pre-commit in the local directory. Note that the pre-commit hook may fail due to unstaged changes. You may wish to stash these changes before committing. This can be done as follows:\ngit add <files-to-be-added>\ngit stash --keep-index\ngit commit\ngit stash pop\n\n\nTesting\nThe testing for this project uses pytest and GitHub workflows for testing. The test suite will be run on GitHub when you submit your pull request.\n\n\nAPI Documentation\nTo build the API documentation do the following from this projects root directory:\n\nInstall required packages:\npython3 -m pip install tiledb-cf[docs]\nMake the HTML document:\nmake -C docs/ html\nOpen docs/_build/html/index.html in a web browser of your choice.\n\n\n\nPull Requests\n\ndev is the development branch, all PR’s should be rebased on top of the latest dev commit.\nCommit changes to a local branch. The convention is to use your initials to identify branches. Branch names should be identifiable and reflect the feature or bug that they want to address / fix. This helps in deleting old branches later.\nWhen ready to submit a PR, git rebase the branch on top of the latest dev commit. Be sure to squash / cleanup the commit history so that the PR preferably one, or a couple commits at most. All commits will be squashed into a single commit upon merging.\nRun the formatting (isort, black) and linting tools (flake8, mypy) before submitting a final PR. Make sure that your contribution generally follows the format and naming conventions used by surrounding code.\nUpdate the HISTORY with any changes/adds/removes to user-facing API or system behavior. Make sure to note any non-backward compatible changes as a breaking change.\nSubmit a PR, writing a descriptive message. If a PR closes an open issue, reference the issue in the PR message (e.g. If an issue closes issue number 10, you would write closes #10)\nMake sure CI (continuous integration) is passing for your PR.\n\n\n\nResources\n\nTileDB-CF-Py\n\nIssues\nDocumentation\n\nTileDB\n\nHomepage\nDocumentation\nForum\nOrganization\n\nGithub / Git\n\nGit cheatsheet\nGithub Documentation\nForking a Repo\nMore Learning Resources"
  },
  {
    "objectID": "documentation/core.html",
    "href": "documentation/core.html",
    "title": "TileDB-CF Core",
    "section": "",
    "text": "Working with large multi-array datasets with complex metadata can be unwieldy. The core TileDB-CF library provides additional support for common operations."
  },
  {
    "objectID": "documentation/netcdf-engine.html",
    "href": "documentation/netcdf-engine.html",
    "title": "TileDB-CF NetCDF Engine",
    "section": "",
    "text": "The NetCDF data model is a common choice for multi-dimensional data, especially in the climate and weather space. NetCDF and TileDB use over lapping terminology to refer to concepts in their respective data model.\nA complete description of the NetCDF data model can be found at the UCAR website.\nA NetCDF file consists of groups, dimensions, variables, and attributes. Each NetCDF file has at least one root group that contains all other objects. Additional subgroups can be added to heirarchically organize the data.\n\nDimensions: A dimension is a name-size pair that describes an axis of a multi-dimension array. The size of the dimension may be “unlimited” (allowed to grow). The NetCDF dimension is roughly ananlogous to a TileDB dimension in a dense TileDB array.\nVariables: A variable is a multi-dimensional array with a NetCDF dimension associated to each axis of the array. The size of the dimensions must match the shape of the multi-dimensional array. A NetCDF variable is roughly equivalent to either a TileDB attribute in a sparse or dense TileDB array or a TileDB dimension in a sparse TileDB array.\nAttribute: An attribute is a key-value pair that is associated with either a group or variable. Attributes are used to store (typically small) metadata. NetCDF attributes are roughly equivalent to TileDB metadata.\nGroup: A NetCDF group is a collection of dimensions, variables, and attributes. A simple NetCDF group might map to a TileDB array. A more complex group would need to be mapped to a TileDB group."
  },
  {
    "objectID": "documentation/netcdf-engine.html#netcdf-to-tiledb-compatibility",
    "href": "documentation/netcdf-engine.html#netcdf-to-tiledb-compatibility",
    "title": "TileDB-CF NetCDF Engine",
    "section": "NetCDF-to-TileDB Compatibility",
    "text": "NetCDF-to-TileDB Compatibility\nThe TileDB-CF package provides an interface for generating TileDB groups from NetCDF datasets using the TileDB-CF Dataspace convention. The CF Dataspace model supports the classic NetCDF-4 data model by mapping:\n\nNetCDF groups to TileDB groups;\nNetCDF dimensions to TileDB dimensions;\nNetCDF variables to TileDB attributes or TileDB dimensions;\nNetCDF attributes to TileDB group or array metadata.\n\nSome features and use cases do not directly transfer or may need to be modified before use in TileDB.\n\nCoordinates: In NetCDF, it is a common convention to name a one-dimensional variable with the same name as its dimension to signify it as a “coordinate” or independent variable other variables are defined on. In TileDB, a variable and dimension in the same array cannot have the same name. This can be handled by renaming either the dimension or the variable when copying to TileDB.\nUnlimited Dimensions: TileDB can support unlimited dimensions by creating the domain on a dimension larger than the initial data. The domain must be set at creation time, and cannot be modified after array creation.\nCompound data types: As of TileDB version 2.16, compound data types are not directly supported in TileDB. Compound data types can be broken into their constituent parts; however, this breaks storage locality. Variable, opaque, and string data types are supported."
  },
  {
    "objectID": "documentation/netcdf-engine.html#programmatic-interface",
    "href": "documentation/netcdf-engine.html#programmatic-interface",
    "title": "TileDB-CF NetCDF Engine",
    "section": "Programmatic Interface",
    "text": "Programmatic Interface\nThe NetCDFConverterEngine is a configurable tool for ingesting data from NetCDF into TileDB. The class can be manually constructed, or it can be auto-generated from a NetCDF file or group."
  },
  {
    "objectID": "documentation/netcdf-engine.html#command-line-interface",
    "href": "documentation/netcdf-engine.html#command-line-interface",
    "title": "TileDB-CF NetCDF Engine",
    "section": "Command-Line Interface",
    "text": "Command-Line Interface\nTileDB-CF provides a command line interface to the NetCDF converter engine. It contains the following options:\n    Usage: tiledb-cf netcdf-convert [OPTIONS]\n\n        Converts a NetCDF input file to nested TileDB groups.\n\n    Options:\n        -i, --input-file TEXT           The path or URI to the NetCDF file that will be converted.  [required]\n\n        -o, --output-uri TEXT           The URI for the output TileDB group. [required]\n\n        --input-group-path TEXT         The path in the input NetCDF for the root group that will be converted.  [default: /]\n\n        --recursive / --no-recursive    Recursively convert all groups contained in the input group path.  [default: True]\n\n        -k, --output-key TEXT           Key for the generated TileDB arrays.\n\n        --unlimited-dim-size INTEGER    Size to convert unlimited dimensions to. [default: 10000]\n\n        --dim-dtype [int8|int16|int32|int64|uint8|uint16|uint32|uint64]\n                                  The data type for TileDB dimensions created from converted NetCDF.  [default: uint64]\n\n        --help                          Show this message and exit."
  },
  {
    "objectID": "documentation/tiledb-cf-spec.html",
    "href": "documentation/tiledb-cf-spec.html",
    "title": "TileDB-CF Dataspace Specification",
    "section": "",
    "text": "Warning\n\n\n\nThe current dataspace specification is not stable. Backwards compatibility is not guaranteed for specification less than 1.0.0."
  },
  {
    "objectID": "documentation/tiledb-cf-spec.html#current-tiledb-cf-dataspace-specification",
    "href": "documentation/tiledb-cf-spec.html#current-tiledb-cf-dataspace-specification",
    "title": "TileDB-CF Dataspace Specification",
    "section": "Current TileDB-CF Dataspace Specification",
    "text": "Current TileDB-CF Dataspace Specification\n\nThe current TileDB-CF format version number is 0.3.0.\n\n\nTileDB-CF Dataspace 0.3.0\nA TileDB CF dataspace is a TileDB group with arrays, attributes, and dimensions that satisfy the following rules.\n\nTerminology\n\nCollection of dimensions: A set of TileDB dimensions with the same name, data type, and domain.\n\n\n\nCF Dataspace\nRequirements for Dimensions\n\nAll dimensions that share a name must belong to the same collection (they must have the same domain and data type).\n\nRequirements for Metadata\n\nAttribute metadata is stored in the same array as the attribute. The metadata key must use the prefix __tiledb_attr.{attr_name}. where {attr_name} is the full name of the attribute.\nDimension metadata is stored in the same array as the dimension. The metadata key must use the prefix __tiledb_dim.{dim_name}. where {dim_name} is the full name of the dimension.\n\n\n\n\nSimple CF Dataspace\nA simple CF dataspace is a direct implementation of the NetCDF data model in TileDB. It follows the same rules as a CF dataspace along with the following requirements:\nAdditional Requirements for Dimensions\n\nAll dimensions use integer indices and have a domain with lower bound of 0.\n\nAdditional Requirements for Arrays\n\nAll arrays in the group are named and have a single attribute.\n\nAdditional Requirements for Metadata\n\nThere is only group and attribute level metadata."
  },
  {
    "objectID": "documentation/tiledb-cf-spec.html#specification-qa",
    "href": "documentation/tiledb-cf-spec.html#specification-qa",
    "title": "TileDB-CF Dataspace Specification",
    "section": "Specification Q&A",
    "text": "Specification Q&A\n\nWhy have a special specification for the TileDB-CF library?\nThe TileDB data model is very general and can be used to support a wide-range of applications. However, there is always a push-and-pull between how general your data model is and enabling specific behavior or interpretations for the data. The purpose of the TileDB-CF specification is to handle the case where we have multiple TileDB arrays defined on the same underlying dimensions. By creating a specificiation we make our assumptions explicit and let users know exactly what they must do to use this tool.\nIs the specification backwards compatible?\nNot yet. This library and data model are still under initial development. When the data model has stabalized we will release a 1.0.0 version.\nWhy is there both a library version and a specification version?\nThe TileDB-CF python package will update much more frequently the specification. The specification is more-or-less just a summary of the conventions the TileDB-CF library is using. As such, a change to the specification version will always coincide to a change to the library version, but the library version can update without effecting the specification.\nWhat version is my current data?\nThe TileDB-CF dataspace specification is fairly minimal. Your data may satisfy multiple versions. Currently, we do not provide support for checking your data satisfies the TileDB-CF dataspace convention, but some such tooling will be implemented before the 1.0.0 release of this specification."
  },
  {
    "objectID": "documentation/tiledb-cf-spec.html#changelog",
    "href": "documentation/tiledb-cf-spec.html#changelog",
    "title": "TileDB-CF Dataspace Specification",
    "section": "Changelog",
    "text": "Changelog\n\nVersion 0.3.0\n\nTerminology\n\nRemove notion of a dataspace name.\n\nCF Dataspace\n\nRemove requirement that all attributes and dimension are named (allow anonymous attributes and dimensions).\nRemove group metadata array. Group metadata is now directly supported in the TileDB core engine.\nRemove the notion of a dataspace name and the associated requirements.\nRemove requirement attributes have unique dataspace names for general CF Datspace.\nRemove requirement of _FillValue.\nAdd dimension-level metadata.\n\nSimple CF Dataspace\n\nRemove requiment all collections of dimension have a unique dataspace name.\nAdd requirement all arrays are uniquely named and have a single attribute.\nAdd restriction that metadata only exists for attributes and groups.\n\n\n\n\nVersion 0.2.0\n\nMajor revision. See appendix for full specification.\n\n\n\nVersion 0.1.0\n\nInitial release. See appendix for full specification."
  },
  {
    "objectID": "documentation/tiledb-cf-spec.html#appendix",
    "href": "documentation/tiledb-cf-spec.html#appendix",
    "title": "TileDB-CF Dataspace Specification",
    "section": "Appendix",
    "text": "Appendix\n\nTileDB-CF Dataspace 0.1.0\n\nTerminology\n\nIndex dimension: A TileDB dimension with an integer data type and domain with 0 as its lower bound.\nData dimension: Any TileDB dimension that is not an index dimension.\nDataspace name: The name of an attribute or dimension stripped of an optional suffix of .index or .data.\n\n\n\nCF Dataspace\nRequirements for Attributes and Dimensions\n\nAll attributes and dimension must be named (there must not be any anonymous attributes or dimensions).\nAll dimensions that share a name must have the same domain and data type.\nAll attributes must have a unique dataspace name.\nIf an attribute and data dimension share the same dataspace name, they must share the same full name and data type.\n\nRequirements for Metadata\n\nGroup metadata is stored in a special metadata array named __tiledb_group inside the TileDB group.\nAttribute metadata is stored in the array the attribute is in using the prefix __tiledb_attr.{attr_name}. for the attribute key where {attr_name} is the full name of the attribute.\nIf the metadata key _FillValue exists for an attribute; it must have the same value as the fill value for the attribute.\n\n\n\nIndexable CF Dataspace\nA CF Dataspace is said to be indexable if it satisfies all requirements of a CF Dataspace along with the following condition:\n\nAll data dimensions must have an axis label that maps an index dimension with the same dataspace name as the data dimension to an attribute with the same full name and data type as the data dimension.\n\n\n\n\nTileDB-CF Dataspace 0.2.0\nA TileDB CF dataspace is a TileDB group with arrays, attributes, and dimensions that satisfy the following rules.\n\nTerminology\n\nDataspace name: The name of an attribute or dimension stripped of an optional suffix of .index or .data.\nCollection of dimensions: A set of TileDB dimensions with the same name, data type, and domain.\n\n\n\nCF Dataspace\nA CF Dataspace is a TileDB group that follows certain requirements in order to provide additional relational context to dimensions and attributes using naming conventions. In a CF Dataspace, TileDB attributes within the entire group are unique and TileDB dimensions that share the same name are considered the same object.\nRequirements for Attributes and Dimensions\n\nAll attributes and dimension must be named (there must not be any anonymous attributes or dimensions).\nAll dimensions that share a name must belong to the same collection (they must have the same domain and data type).\nAll attributes must have a unique dataspace name.\n\nRequirements for Metadata\n\nGroup metadata is stored in a special metadata array named __tiledb_group inside the TileDB group.\nAttribute metadata is stored in the same array the attribute is stored in. The metadata key must use the prefix __tiledb_attr.{attr_name}. where {attr_name} is the full name of the attribute.\nIf the metadata key _FillValue exists for an attribute; it must have the same value as the fill value for the attribute.\n\n\n\n\nSimple CF Dataspace\nA simple CF dataspace is a direct implementation of the NetCDF data model in TileDB. It follows the same rules as a CF dataspace along with the following requirements:\nAdditional Requirements for Dimensions\n\nAll dimensions use integer indices and have a domain with lower bound of 0.\nAll collections of dimensions must have a unique dataspace name."
  },
  {
    "objectID": "documentation/xarray-engine.html",
    "href": "documentation/xarray-engine.html",
    "title": "TileDB-CF Xarray Engine",
    "section": "",
    "text": "Xarray uses a plugin infrastructure that allows third-party developers to create their own backend engines for reading data into xarray. TileDB-CF contains one such backend. To use the backend, make sure tiledb-cf is installed in your current Python environment, and use the tiledb engine:\nimport xarray as xr\n\nxr.open_dataset(tiledb_uri, engine=\"tiledb\")\nThe TileDB engine can be used to open either a TileDB array or a TileDB group. See the requirements on the arrays below.\nThe backend engine will open the group or array as a dataset with TileDB dimensions mapping to dataset dimensions, TileDB attributes mapping to dataset variables/DataArrays, and TileDB metadata mapping to dataset attributes.\nFor a TileDB array to be readable by xarray, the following must be satisfied:\n\nThe array must be dense.\nAll dimensions on the array must be either signed or unsigned integers.\nAdd dimensions must have a domain that starts at 0.\n\nFor a TileDB group to be readable by xarray, the following must be satisfied:\n\nAll arrays in the group satisfy the above requirements for the array to be readable.\nEach attribute has a unique “variable name”.\n\nThe TileDB backend engine can be used with the standard xarray keyword arguments. It supports the additional TileDB-specific arguments:\n\nconfig: An optional TileDB configuration object to use in arrays and groups.\nctx: An optional TileDB context object to use for all TileDB operations.\ntimestamp: An optional timestamp to open the TileDB array at (not supported on groups)."
  },
  {
    "objectID": "documentation/xarray-engine.html#writing-from-xarray-to-tiledb",
    "href": "documentation/xarray-engine.html#writing-from-xarray-to-tiledb",
    "title": "TileDB-CF Xarray Engine",
    "section": "Writing from Xarray to TileDB",
    "text": "Writing from Xarray to TileDB\nThe xarray writer is stricter than the xarray backend engine (reader). While the reader will attempt to open arrays with multiple attributes, the xarray writer only creates arrays with one attribute per name.\nThere are two sets of functions for writing to xarray:\n\nSingle dataset ingestion.\n\nFunctions used: from_xarray\nUseful when copying an entire xarray dataset to a TileDB group in a single function call.\nCreates the group and copies all data and metadata to the new group in a single function call.\n\nMulti-dataset ingestion.\n\nMain functions: create_group_from_xarray and copy_data_from_xarray.\nAdditional helper function: copy_metadata_from_xarray.\nUseful when copying multiple xarray datasets to a single TileDB group.\nCreates the group and copies data to the group in separate API calls.\n\n\nThe xarray to TileDB writer will copy the dataset in the following way:\n\nOne group is created for the dataset.\nDataset “attributes” are copied to group level metadata.\nEach xarray variable is copied to its own dense TileDB array with a single TileDB attribute.\n\nThe array schema for an xarray variable is generated as follows:\n\nTileDB array properties:\n\nThe TileDB array is dense.\n\nTileDB Domain:\n\nAll dimensions have the same datatype determined by the dim_dtype encoding.\nThe dimension names in the TileDB array match the dimension names in the xarray variable.\nThe dimension tiles are determined by the tiles encoding.\nThe domain of each dimension is set to [0, max_size - 1] where max_size is computed as follows:\n\nUse the corresponding element of the max_shape encoding if provided.\nIf the max_shape encoding is not provided and the xarray dimension is “unlimited”, use the largest possible size for this integer type.\nIf the max_shape encoding is not provided and the xarray dimension is not “unlimited”, use the size of the xarray dimension.\n\n\nTileDB Attribute:\n\nThe attribute datatype is the same as the variable datatype (after applying xarray encodings).\nThe attribute name is set using the following:\n\nUse the name provided by attr_name encoding.\nIf the attr_name encoding is not provided and there is no dimension on this variable with the same name as the variable, use the name of the variable.\nIf the attr_name encoding is provided and there is a dimension on this variable with the same name as the variable, use the variable name appended with _.\n\nThe attribute filters are determined by the filters encoding.\n\n\n\nTileDB Encoding\nThe writer takes a dictionary from dataset variable names to a dictionary of encodings for setting TileDB properties. The possible encoding keywords are provided in the table below.\n\n\n\n\n\n\n\n\nEncoding Keyword\nDetails\nType\n\n\n\n\nattr_name\nName to use for the TileDB attribute.\nstr\n\n\nfilters\nFilter list to apply to the TileDB attribute.\ntiledb.FilterList\n\n\ntiles\nTile sizes to apply to the TileDB dimensions.\ntuple of ints\n\n\nmax_shape\nMaximum possible size of the TileDB array.\ntuple of ints\n\n\ndim_dtype\nDatatype to use for the TileDB dimensions.\nstr or numpy.dtype\n\n\n\n\n\nRegion to Write\nIf the creating TileDB array’s with either unlimited dimensions or with encoded max_shape larger than the current size of the xarray variable, then the region to write the data to needs to be provided. This is input as a dictionary from dimension names to slices. The slice uses xarray/numpy conventions and will write to a region that does not include the upper bound of the slice.\n\n\nCreating Multiple Fragments\nWhen copying data with either the from_xarray or copy_data_from_xarray functions, the copy routine will use Xarray chunks for separate writes - creating multiple fragments."
  },
  {
    "objectID": "examples/core/group-basics.html",
    "href": "examples/core/group-basics.html",
    "title": "",
    "section": "",
    "text": "This notebook contains an example of how to use TileDB and TileDB-CF to create, inspect, open, read, and write data to arrays in a TileDB group.\n\n\nThe following arrays will be created that share some of their dimensions:\n\ndense_3d is a dense array with dimensions dense_x, dense_y and dense_t\ndense_2d is a dense array with dimensions dense_x and dense_y\ndense_1d is a dense array with dimension dense_t\nsparse_4d is a sparse array with dimensions sparse_x sparse_y sparse_z and sparse_t\ndense_axes_xy is a dense array that contains the values of the dense_x and dense_y dimensions as dense_x_data and dense_y_data\ndense_axes_t is a dense array that contains the values of the dense_t dimension as dense_t_data\nsparse_axes is a sparse array that contains the values of the sparse_x sparse_y sparse_z and sparse_t dimensions as sparse_x_data sparse_y_data sparse_z_data and sparse_t_data\n\n\n\n\nImport the libraries used in this notebook:\n\nimport time\nimport numpy as np\nimport pandas as pd\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\nimport tiledb\nfrom tiledb.cf import AttrMetadata, ArrayMetadata, create_group, open_group_array\n\n\n\n\nVariables to set the size of the arrays:\n\ndense_size = 100\nsparse_size = 2000\nt_size = 365\n\nFunctions used to create a dataset:\n\ndef ripple(x, y, t):\n    return np.sin(t * (x**2 + y**2)) / (t + 1)\n\n\ndef ripple2(x, y, z, t):\n    return (np.sin(t * (x**2 + y**2)) / (t + 1)) + z\n\n\n\n\ndense_x_values = np.arange(1, dense_size + 1)\ndense_y_values = np.arange(1, dense_size + 1)\ndense_t_values = np.arange(1, t_size + 1)\n\ndense_3d_values = np.fromfunction(\n    lambda x, y, t: ripple(x, y, t), (dense_size, dense_size, t_size)\n)\n\ndense_2d_values = np.nanmean(dense_3d_values, axis=2)\ndense_1d_values = np.mean(dense_3d_values, axis=(0, 1))\n\n\ndense_3d_values = np.fromfunction(\n    lambda x, y, t: ripple(x, y, t), (dense_size, dense_size, t_size)\n)\n\ndense_2d_values = np.nanmean(dense_3d_values, axis=2)\ndense_1d_values = np.mean(dense_3d_values, axis=(0, 1))\n\n\n\n\n\nsparse_x_values = np.random.randint(1, dense_size + 1, size=(sparse_size))\nsparse_y_values = np.random.randint(1, dense_size + 1, size=(sparse_size))\nsparse_z_values = np.random.randint(1, dense_size + 1, size=(sparse_size))\nsparse_t_values = np.random.randint(1, t_size + 1, size=(sparse_size))\n\nsparse_4d_values = ripple2(\n    sparse_x_values, sparse_y_values, sparse_z_values, sparse_t_values\n)\n\n\n\n\n\n\nArraySchema\nDomain\nAttributes\nDimensions\n\n\ndense_x = tiledb.Dim(name=\"dense_x\", domain=(1, dense_size), tile=10, dtype=np.uint64)\ndense_y = tiledb.Dim(name=\"dense_y\", domain=(1, dense_size), tile=10, dtype=np.uint64)\ndense_t = tiledb.Dim(name=\"dense_t\", domain=(1, t_size), tile=10, dtype=np.uint64)\nsparse_x = tiledb.Dim(\n    name=\"sparse_x\", domain=(1, sparse_size), tile=10, dtype=np.uint64\n)\nsparse_y = tiledb.Dim(\n    name=\"sparse_y\", domain=(1, sparse_size), tile=10, dtype=np.uint64\n)\nsparse_z = tiledb.Dim(\n    name=\"sparse_z\", domain=(1, sparse_size), tile=10, dtype=np.uint64\n)\nsparse_t = tiledb.Dim(name=\"sparse_t\", domain=(1, t_size), tile=10, dtype=np.uint64)\n\n\narray_schemas = {\n    \"dense_3d\": tiledb.ArraySchema(\n        domain=tiledb.Domain(dense_x, dense_y, dense_t),\n        attrs=[\n            tiledb.Attr(name=\"dense_3d_data\", dtype=np.float64),\n        ],\n    ),\n    \"dense_2d\": tiledb.ArraySchema(\n        domain=tiledb.Domain(dense_x, dense_y),\n        attrs=[\n            tiledb.Attr(name=\"dense_2d_data\", dtype=np.float64),\n        ],\n    ),\n    \"dense_1d\": tiledb.ArraySchema(\n        domain=tiledb.Domain(dense_t),\n        attrs=[\n            tiledb.Attr(name=\"dense_1d_data\", dtype=np.float64),\n        ],\n    ),\n    \"sparse_4d\": tiledb.ArraySchema(\n        domain=tiledb.Domain(sparse_x, sparse_y, sparse_z, sparse_t),\n        attrs=[\n            tiledb.Attr(name=\"sparse_4d_data\", dtype=np.float64),\n        ],\n        sparse=True,\n        allows_duplicates=True,\n    ),\n    \"dense_axes_xy\": tiledb.ArraySchema(\n        domain=tiledb.Domain(dense_x),\n        attrs=[\n            tiledb.Attr(name=\"dense_x_data\", dtype=np.uint64),\n            tiledb.Attr(name=\"dense_y_data\", dtype=np.uint64),\n        ],\n    ),\n    \"dense_axes_t\": tiledb.ArraySchema(\n        domain=tiledb.Domain(dense_t),\n        attrs=[\n            tiledb.Attr(name=\"dense_t_data\", dtype=np.uint64),\n        ],\n    ),\n    \"sparse_axes\": tiledb.ArraySchema(\n        domain=tiledb.Domain(sparse_x),\n        attrs=[\n            tiledb.Attr(name=\"sparse_x_data\", dtype=np.uint64),\n            tiledb.Attr(name=\"sparse_y_data\", dtype=np.uint64),\n            tiledb.Attr(name=\"sparse_z_data\", dtype=np.uint64),\n            tiledb.Attr(name=\"sparse_t_data\", dtype=np.uint64),\n        ],\n        sparse=True,\n        allows_duplicates=True,\n    ),\n}\n\n\n\n\ngroup_uri = \"output/example_group\"\nif tiledb.object_type(group_uri) is None:\n    create_group(\"output/example_group\", array_schemas)\n\n\n\n\nWriting to dense and sparse arrays uses standard TileDB write operations. Arrays can be opened one-by-one or multiple arrays can be opened at once.\n\nwith tiledb.Group(group_uri, mode=\"r\") as group:\n    with (\n        open_group_array(group, attr=\"dense_3d_data\", mode=\"w\") as dense_3d_array,\n        open_group_array(group, attr=\"dense_2d_data\", mode=\"w\") as dense_2d_array,\n        open_group_array(group, attr=\"dense_1d_data\", mode=\"w\") as dense_1d_array,\n    ):\n        dense_3d_array[:] = dense_3d_values\n        dense_2d_array[:] = dense_2d_values\n        dense_1d_array[:] = dense_1d_values\n    with (\n        open_group_array(group, attr=\"sparse_4d_data\", mode=\"w\") as sparse_data_array,\n        open_group_array(group, array=\"sparse_axes\", mode=\"w\") as sparse_axes_array,\n    ):\n        sparse_data_array[\n            sparse_x_values, sparse_y_values, sparse_z_values, sparse_t_values\n        ] = sparse_4d_values\n        sparse_axes_array[np.arange(sparse_size) + 1] = {\n            \"sparse_x_data\": sparse_x_values,\n            \"sparse_y_data\": sparse_y_values,\n            \"sparse_z_data\": sparse_z_values,\n            \"sparse_t_data\": sparse_t_values,\n        }\n    with (\n        open_group_array(group, array=\"dense_axes_xy\", mode=\"w\") as xy_array,\n        open_group_array(\n            group, array=\"dense_axes_t\", attr=\"dense_t_data\", mode=\"w\"\n        ) as t_array,\n    ):\n        xy_array[:] = {\"dense_x_data\": dense_x_values, \"dense_y_data\": dense_y_values}\n        t_array[:] = dense_t_values\n\n\n\nWrite Group metadata:\n\nwith tiledb.Group(group_uri, mode=\"w\") as group:\n    group.meta[\"description\"] = \"Example TileDB Group\"\n    group.meta[\"version\"] = \"1.0\"\n    group.meta[\"created on \"] = time.ctime(time.time())\n\nWrite Array metadata:\n\nwith tiledb.Group(group_uri, mode=\"r\") as group:\n    with open_group_array(group, array=\"dense_3d\", mode=\"w\") as dense_3d_array:\n        dense_3d_array.meta[\n            \"description\"\n        ] = \"Example 3D dense array with dimensions x, y and t\"\n    with open_group_array(group, array=\"dense_axes_xy\", mode=\"w\") as xy_array:\n        xy_array.meta[\n            \"description\"\n        ] = \"Values for the x and y dimensions of the 3D dense array\"\n\nWrite Attribute metadata using the AttrMetadata class:\n\nwith tiledb.Group(group_uri, mode=\"r\") as group:\n    with open_group_array(group, array=\"dense_axes_xy\", mode=\"w\") as array:\n        x_attr_meta = AttrMetadata(array.meta, \"dense_x_data\")\n        x_attr_meta[\"description\"] = \"Values of x\"\n\n\n\n\n\n\n\nRead the Group metadata keys and their values:\n\nwith tiledb.Group(group_uri) as group:\n    for key, value in group.meta.items():\n        print(f\"{key}: {value}\")\n\nRead the metadata for the dense_axes_xy array. Optionally, you can filter the array attribute data using the AttrMetadata and ArrayMetadata.\n\nwith tiledb.Group(group_uri) as group:\n    with open_group_array(group, array=\"dense_axes_xy\") as array:\n        print(\"All metadata in the array:\")\n        for key, value in array.meta.items():\n            print(f\"    * {key}: {value}\")\n        print(\"Only array metadata:\")\n        for key, value in ArrayMetadata(array.meta).items():\n            print(f\"    * {key}: {value}\")\n        print(\"Only attribute metadata for 'dense_x_data':\")\n        for key, value in AttrMetadata(array.meta, \"dense_x_data\").items():\n            print(f\"    * {key}: {value}\")\n\n\n\n\n\nwith tiledb.Group(group_uri) as group:\n    with (\n        open_group_array(group, array=\"dense_3d\", attr=\"dense_3d_data\") as data_array,\n        open_group_array(group, array=\"dense_axes_xy\") as axes_array,\n    ):\n        dense_3d_data = data_array[:]\n        axes_data = axes_array[...]\n        dense_x_data = axes_data[\"dense_x_data\"]\n        dense_y_data = axes_data[\"dense_y_data\"]\n\n\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 12))\naxes[0, 0].contourf(dense_x_data, dense_y_data, dense_3d_data[:, :, 33])\naxes[0, 1].contourf(dense_x_data, dense_y_data, dense_3d_data[:, :, 66])\naxes[1, 0].contourf(dense_x_data, dense_y_data, dense_3d_data[:, :, 99])\naxes[1, 1].contourf(dense_x_data, dense_y_data, dense_3d_data[:, :, 95]);\n\n\nwith tiledb.Group(group_uri) as group:\n    with open_group_array(group, array=\"sparse_4d\") as array:\n        df = pd.DataFrame(array[...])\n\ndf.head()\n\n\ndf.describe().transpose()\n\n\ndf.plot.scatter(x=\"sparse_x\", y=\"sparse_4d_data\");\n\n\nwith tiledb.Group(group_uri) as group:\n    with open_group_array(group, array=\"dense_1d\") as array:\n        df2 = pd.DataFrame(array[...])\n\ndf2.head()\n\n\ndf2.plot();"
  },
  {
    "objectID": "examples/netcdf_engine/netcdf-to-tiledb-set-max-fragment-size.html",
    "href": "examples/netcdf_engine/netcdf-to-tiledb-set-max-fragment-size.html",
    "title": "",
    "section": "",
    "text": "This shows a simple example of copying a NetCDF file in multiple chunks by setting the maximum fragment size for arrays in the NetCDF4ConverterEngine.\n\n\n\n\nDimensions:\n\nx: size=8\ny: size=8\nz: size=8\n\nVariables:\n\nf(x, y, z) = [0, …, 511]\n\n\n\n\n\nThis example requires the following python packages are installed: netCDF4, numpy, tiledb, and tiledb-cf\n\nimport netCDF4\nimport numpy as np\nimport tiledb\nimport tiledb.cf\n\n\n# Set names for the output generated by the example.\noutput_dir = \"output/netcdf-to-tiledb-set-max-fragment-size\"\nnetcdf_file = f\"{output_dir}/simple1.nc\"\narray_uri = f\"{output_dir}/simple_copy_chunks\"\n\n\n# Reset output folder\nimport os\nimport shutil\n\nshutil.rmtree(output_dir, ignore_errors=True)\nos.mkdir(output_dir)\n\n\nwith netCDF4.Dataset(netcdf_file, mode=\"w\") as dataset:\n    dataset.setncatts({\"title\": \"Simple dataset for examples\"})\n    dataset.createDimension(\"x\", 8)\n    dataset.createDimension(\"y\", 8)\n    dataset.createDimension(\"z\", 8)\n    f = dataset.createVariable(\"f\", np.int64, (\"x\", \"y\", \"z\"))\n    f[:, :, :] = np.reshape(np.arange(512), (8, 8, 8))\nprint(f\"Created example NetCDF file `{netcdf_file}`.\")\n\n\n# Create NetCDF4 converter and print output\nconverter = tiledb.cf.NetCDF4ConverterEngine.from_file(netcdf_file)\nconverter\n\n\n# Set max_fragment_shape for array\nconverter.get_array_creator(\"array0\").domain_creator.max_fragment_shape = (4, 8, 2)\nconverter\n\n\n# Run conversion (using `convert_to_array` since there is only 1 array in the group)\n# Consolidate fragment metadata (recommended for copying multiple fragments)\nconverter.convert_to_array(array_uri)\ntiledb.consolidate(\n    array_uri, config=tiledb.Config({\"sm.consolidation.mode\": \"fragment_meta\"})\n)\n\n\n# View fragments information to confirm multiple separate chunks were copied\nfragment_info = tiledb.FragmentInfoList(array_uri)\nprint(f\"Number of fragments: {len(fragment_info)}\")\nfor frag in fragment_info:\n    print(\n        f\"Fragment {frag.num}: nonempty_domain={frag.nonempty_domain}, has_consolidated_metadata={frag.has_consolidated_metadata}\"\n    )"
  },
  {
    "objectID": "examples/netcdf_engine/netcdf-to-tiledb-set-tiles.html",
    "href": "examples/netcdf_engine/netcdf-to-tiledb-set-tiles.html",
    "title": "",
    "section": "",
    "text": "This example shows how to set the tile size for TileDB arrays that will be created by a NetCDF4ConverterEngine.\n\n\n\nThis example shows convertering a small NetCDF file with 2 dimensions and 4 variables:\n\nDimensions:\n\nx: size=100\ny: size=100\n\nVariables:\n\nx(x)\ny(y)\nA1(x, y)\nA1(x, y)\n\n\n\n\n\nThis example requires the following python packages are installed: netCDF4, numpy, tiledb, tiledb-cf\n\nimport netCDF4\nimport numpy as np\nimport tiledb\nimport tiledb.cf\n\n\n# Set names for the output generated by the example.\noutput_dir = \"output/netcdf-to-tiledb-set-filters\"\nnetcdf_file = f\"{output_dir}/simple1.nc\"\n\n\n# Reset output folder\nimport os\nimport shutil\n\nshutil.rmtree(output_dir, ignore_errors=True)\nos.mkdir(output_dir)\n\n\n# Create sample NetCDF file with no data\nwith netCDF4.Dataset(netcdf_file, mode=\"w\") as dataset:\n    dataset.createDimension(\"x\", 100)\n    dataset.createDimension(\"y\", 100)\n    A1 = dataset.createVariable(\"A1\", np.float64, (\"x\", \"y\"))\n    A2 = dataset.createVariable(\"A2\", np.float64, (\"x\", \"y\"))\n    x1 = dataset.createVariable(\"x\", np.float64, (\"x\",))\n    y = dataset.createVariable(\"y\", np.float64, (\"y\",))\nprint(f\"Created example NetCDF file `{netcdf_file}`.\")\n\n\n\n\n\nWhen using the NetCDF4ConverterEngine class, the most straight forward way to set tile sizes is by directly setting them after the arrays have been added to the converter engine. This can be done by accessing the array_creator and setting the tile property in the DomainCreator or in individual DimensionConverters.\n\nconverter = tiledb.cf.NetCDF4ConverterEngine.from_file(netcdf_file)\nconverter\n\n\n# Set tile size with domain creator\nconverter.get_array_creator(\"array0\").domain_creator.tiles = (50,)\nconverter.get_array_creator_by_attr(\"y.data\").domain_creator.tiles = (50,)\n\n\n# Set tile size with the dimension creators\narray1_domain = converter.get_array_creator(\"array1\").domain_creator\narray1_domain.dim_creator(\"x\").tile = 10\narray1_domain.dim_creator(\"y\").tile = 20\n\n\nprint(f\"Generated TileDB Arrays:\")\nfor array_creator in converter.array_creators():\n    print(\n        f\"  * {array_creator.name}({', '.join(dim_creator.name for dim_creator in array_creator.domain_creator)})\"\n    )\n    print(f\"      - tiles: {array_creator.domain_creator.tiles}\")\n\n\n\n\nThe tile sizes in arrays can be set when using the NetCDF4ConverterEngine class methods from_group and from_file. The tile sizes can be set for the array that contains a particular variable using the tiles_by_var parameter or for arrays defined over a particular domain using tiles_by_dims.\nHow tiles_by_vars and tiles_by_dims interact if there is conflicting tile sizes depends on if the collect_attrs parameter was True or False.\n\nSet the array grouping. A NetCDF variable maps to TileDB attributes. The collect_attrs parameters determines if each NetCDF variable is stored in a separate array, or if all NetCDF variables with the same underlying dimensions are stored in the same TileDB array. Scalar variables are always grouped together.\n\ncollect_attrs: If True, store all attributes with the same dimensions in the same array. Otherwise, store each attribute in a separate array.\n\nThe tiles_by_var parameter is a mapping from variable name to the tiles for the dimensions of the array that variable is stored in. The tiles_by_dims parameter is a mapping from the names of the dimensions of the array to the tiles for the dimensions of the array. If using collect_attrs=True, then tiles_by_dims will over-write tiles_by_var. If using collect_attrs=False, then tiles_by_vars with over-write tiles_by_var.\n\n\n# Try changing the parameters, `collect_attrs`, `tiles_by_dims`, and `tiles_by_var` and see how it effects the tile size for all dimensions\ndef test_setting_tiles(**kwargs):\n    print(f\"Keyword arguments: {kwargs}\")\n    with netCDF4.Dataset(\"tmp.nc\", mode=\"w\", diskless=True) as netcdf_group:\n        # Create a NetCDF group that only exists in memory.\n        netcdf_group.createDimension(\"x\", 100)\n        netcdf_group.createDimension(\"y\", 100)\n        netcdf_group.createVariable(\"A1\", np.float64, (\"x\", \"y\"))\n        netcdf_group.createVariable(\"A2\", np.float64, (\"x\", \"y\"))\n        netcdf_group.createVariable(\"x\", np.float64, (\"x\",))\n        netcdf_group.createVariable(\"y\", np.float64, (\"y\",))\n        # Convert the group with the provided keyword arguments.\n        converter = tiledb.cf.NetCDF4ConverterEngine.from_group(\n            netcdf_group=netcdf_group, **kwargs\n        )\n        print(f\"Generated TileDB Arrays:\")\n        for array_creator in converter.array_creators():\n            print(\n                f\"  * {array_creator.name}({', '.join(dim_creator.name for dim_creator in array_creator.domain_creator)})\"\n            )\n            print(\n                f\"      - attributes: {', '.join(attr_creator.name for attr_creator in array_creator)}\"\n            )\n            print(f\"      - tiles: {array_creator.domain_creator.tiles}\")\n\n\n# 1. `collect_attrs=True`\n#    * `A1` and `A2` are in the same array.\n#    * `tile=None` for all dimensions.\ntest_setting_tiles(collect_attrs=True)\n\n\n# 2. `collect_attrs=True`, `tiles_by_dims={(x,y): (10, 20)}`\n#     * `A1` and `A2` are in the same array.\n#     * Only array with dimensions `(x,y)` has tiles set.\ntest_setting_tiles(collect_attrs=True, tiles_by_dims={(\"x\", \"y\"): (10, 20)})\n\n\n# 3. `collect_attrs=True`, `tiles_by_var={'A1': (50, 50)}`\n#    * `A1` and `A2` are in the same array.\n#    * Only array with variable `A1` has tiles set.\ntest_setting_tiles(collect_attrs=True, tiles_by_var={\"A1\": (50, 50)})\n\n\n# 4. `collect_attrs=True`, `tiles_by_dims={(x,y): (10, 20)}`, `tiles_by_var={'A1': (50, 50)}`\n#     * `A1` and `A2` are in the same array.\n#     * Only array with dimensions `(x,y)` has tiles set. `tiles_by_dims` took priority over `tiles_by_var`.\ntest_setting_tiles(\n    collect_attrs=True,\n    tiles_by_var={\"A1\": (50, 50)},\n    tiles_by_dims={(\"x\", \"y\"): (10, 20)},\n)\n\n\n# 5. `collect_attrs=False`\n#     * `A1` and `A2` are in separate arrays.\n#     * `tile=None` for all dimensions.\ntest_setting_tiles(collect_attrs=False)\n\n\n# 6. `collect_attrs=False`, `tiles_by_dims={(x,y): (10, 20)}`\n#     * `A1` and `A2` are in separate arrays.\n#     * Only arrays with dimensions `(x,y)` have tiles set.\ntest_setting_tiles(collect_attrs=False, tiles_by_dims={(\"x\", \"y\"): (10, 20)})\n\n\n# 7. `collect_attrs=False`, `tiles_by_var={'A1': (50, 50)}`\n#     * `A1` and `A2` are in separate arrays.\n#     * Only array with variable `A1` has tiles set.\ntest_setting_tiles(collect_attrs=False, tiles_by_var={\"A1\": (50, 50)})\n\n\n# 8. `collect_attrs=False`, `tiles_by_dims={(x,y): (10, 20)}`, `tiles_by_var={'A1': (50, 50)}`\n#     * `A1` and `A2` are in separate arrays.\n#     * The array with `A2` has tiles set by `tiles_by_dims`.\n#     * The array with `A1` has tiles set. `tiles_by_var` took priority over `tiles_by_dims`.\ntest_setting_tiles(\n    collect_attrs=False,\n    tiles_by_var={\"A1\": (50, 50)},\n    tiles_by_dims={(\"x\", \"y\"): (10, 20)},\n)"
  },
  {
    "objectID": "examples/netcdf_engine/netcdf-to-tiledb-basics.html",
    "href": "examples/netcdf_engine/netcdf-to-tiledb-basics.html",
    "title": "",
    "section": "",
    "text": "The purpose of this example is to show the basics of converting a NetCDF file to TileDB arrays.\nThis includes:\n\nOptions for auto-generating a converter from a NetCDF file.\nChanging the TileDB schema settings before conversion.\nCreating the TileDB group and copying data from the NetCDF file to the TileDB arrays.\n\n\n\n\nThis example shows convertering a small NetCDF file with 2 dimensions and 4 variables:\n\nDimensions:\n\nx: size=100\ny: size=100\n\nVariables:\n\nx(x)\n\ndescription: evenly spaced values from -5 to 5\ndata type: 64-bit floating point\n\ny(y)\n\ndescription: evenly spaced values from -5 to 5\ndata type: 64-bit floating point\n\nA1(x, y)\n\ndescription: x + y\ndata type: 64-bit floating point\n\nA1(x, y)\n\ndescription: sin((x/2)^2 + y^2\ndata type: 64-bit floating point\n\n\n\n\n\n\nThis example requires the following python packages are installed: netCDF4, numpy, tiledb, tiledb-cf, and matplotlib\n\nimport netCDF4\nimport numpy as np\nimport tiledb\nimport tiledb.cf\nimport matplotlib.pyplot as plt\n\n\n# Set names for the output generated by the example.\noutput_dir = \"output/netcdf-to-tiledb-basics\"\nnetcdf_file = f\"{output_dir}/simple1.nc\"\ngroup_uri = f\"{output_dir}/simple_netcdf_to_group_1\"\narray_uri = f\"{output_dir}/simple_netcdf_to_array_1\"\n\n\n# Reset output folder\nimport os\nimport shutil\n\nshutil.rmtree(output_dir, ignore_errors=True)\nos.mkdir(output_dir)\n\n\n\n\n\nIf the NetCDF file does not exist, we create a small NetCDF file for this example.\n\nx_data = np.linspace(-5.0, 5.0, 100)\ny_data = np.linspace(-5.0, 5.0, 100)\nxv, yv = np.meshgrid(x_data, y_data, sparse=True)\nwith netCDF4.Dataset(netcdf_file, mode=\"w\") as dataset:\n    dataset.setncatts({\"title\": \"Simple dataset for examples\"})\n    dataset.createDimension(\"x\", 100)\n    dataset.createDimension(\"y\", 100)\n    A1 = dataset.createVariable(\"A1\", np.float64, (\"x\", \"y\"))\n    A1.setncattr(\"full_name\", \"Example matrix A1\")\n    A1.setncattr(\"description\", \"x + y\")\n    A1[:, :] = xv + yv\n    A2 = dataset.createVariable(\"A2\", np.float64, (\"x\", \"y\"))\n    A2[:, :] = np.sin((xv / 2.0) ** 2 + yv**2)\n    A2.setncattr(\"full_name\", \"Example matrix A2\")\n    A2.setncattr(\"description\", \"sin((x/2)^2 + y^2\")\n    x1 = dataset.createVariable(\"x\", np.float64, (\"x\",))\n    x1[:] = x_data\n    y = dataset.createVariable(\"y\", np.float64, (\"y\",))\n    y[:] = y_data\nprint(f\"Created example NetCDF file `{netcdf_file}`.\")\n\n\n\n\nIn this section we convert a NetCDF file to TileDB in a way that:\n\nmaps NetCDF dimensions to TileDB dimensions,\nmaps NetCDF variables to TileDB attributes.\n\nThe functions NetCDF4ConverterEngine.from_file and NetCDF4ConverterEngine.from_group auto-generate a NetCDF4ConverterEngine for an exising NetCDF file. The properties in the NetCDF4ConverterEngine can be modified after the converter is generated.\nParameters:\n\nSet the location of the NetCDF group to be converted.\n\nIn from_file:\n\ninput_file: The input NetCDF file to generate the converter engine from.\ngroup_path: The path to the NetCDF group to copy data from. Use '/' for the root group.\n\nIn from_group:\n\ninput_netcdf_group: The NetCDF group to generate the converter engine from. (Must be a netCDF4.Dataset or netCDF4.Group.)\n\n\nSet the array grouping. A NetCDF variable maps to TileDB attributes. The collect_attrs parameters determines if each NetCDF variable is stored in a separate array, or if all NetCDF variables with the same underlying dimensions are stored in the same TileDB array. Scalar variables are always grouped together.\n\ncollect_attrs: If True, store all attributes with the same dimensions in the same array. Otherwise, store each attribute in a separate array.\n\nSet default properties for TileDB dimension.\n\nunlimited_dim_size: The default size of the domain for TileDB dimensions created from unlimited NetCDF dimensions. If None, the current size of the NetCDF dimension will be used.\ndim_dtype: The default numpy dtype to use when converting a NetCDF dimension to a TileDB dimension.\n\nSet tile sizes for TileDB dimensions. Multiple arrays in the TileDB group may have the same name, domain, and type, but different tiles and compression filters. The tiles_by_var and tiles_by_dims parameters allow a way of setting the tiles for the dimensions in different arrays.\n\ntiles_by_var: A map from the name of a single NetCDF variable to the tiles of the dimensions of the TileDB array that contains the data from that variable.\ntiles_by_dims: A map from the name of NetCDF dimensions defining a variable to the tiles of the dimensions of any TileDB array that contains data from a variable defined on those dimensions.\n\nConvert 1D variables with the same name and dimension to a TileDB dimension instead of a TileDB attribute. This is an advanced usage, and will move the data away from a NetCDF-like data model.\n\ncoords_to_dims: If True, convert the NetCDF coordinate variable into a TileDB dimension for sparse arrays. Otherwise, convert the coordinate dimension into a TileDB dimension and the coordinate variable into a TileDB attribute.\n\nUnpack NetCDF data that uses add_offset and scale_factor.\n\nunpack_vars: If True, for any variable that has NetCDF attributes add_offset or scale_factor apply linear transformation x -> add_offset * x + scale_factor to data before conversion. The data type will be set to the data type of the scaled data and the attributes add_offset and scale_factor will be dropped.\n\nSet filters for TileDB dimensions, attributes, and offsets.\n\noffsets_filters: Default TileDB filters for all offsets for variable length TileDB attributes and TileDB dimensions.\nattrs_filters: Default TileDB filters for all attributes.\n\n\n\n# Auto-generate NetCDF to TileDB conversion from a NetCDF file.\nconverter = tiledb.cf.NetCDF4ConverterEngine.from_file(\n    netcdf_file,\n    dim_dtype=np.uint32,\n    attrs_filters=[tiledb.ZstdFilter(level=7)],\n)\nconverter\n\n\n# Update properties manually by modifying the array creators\n# 1. Update properties for x\nx_array = converter.get_array_creator_by_attr(\"x.data\")\nx_array.name = \"x\"\nx_array.domain_creator.tiles = (20,)\n# 2. Update properties for y\ny_array = converter.get_array_creator_by_attr(\"y.data\")\ny_array.name = \"y\"\ny_array.domain_creator.tiles = (20,)\n# 3. Update properties for array of matrices\ndata_array = converter.get_array_creator_by_attr(\"A1\")\ndata_array.name = \"data\"\ndata_array.domain_creator.tiles = (20, 20)\nconverter\n\nRun the conversions to create two dense TileDB arrays:\n\nconverter.convert_to_group(group_uri)\n\n\n\nOpen the attributes from the generated TileDB group:\n\nwith tiledb.Group(group_uri) as group:\n    with (\n        tiledb.cf.open_group_array(group, attr=\"x.data\") as x_array,\n        tiledb.cf.open_group_array(group, attr=\"y.data\") as y_array,\n        tiledb.cf.open_group_array(group, array=\"data\") as data_array,\n    ):\n        x = x_array[:]\n        y = y_array[:]\n        data = data_array[...]\n        A1 = data[\"A1\"]\n        A2 = data[\"A2\"]\n        a1_description = tiledb.cf.AttrMetadata(data_array.meta, \"A1\")[\"description\"]\n        a2_description = tiledb.cf.AttrMetadata(data_array.meta, \"A2\")[\"description\"]\n\n\nfig, axes = plt.subplots(nrows=1, ncols=2)\naxes[0].contourf(x, y, A1)\naxes[0].set_title(a1_description)\naxes[1].contourf(x, y, A2)\naxes[1].set_title(a2_description);\n\n\n\n\n\nIn this section we convert a NetCDF file to TileDB in a way taht:\n\nmaps NetCDF ‘coordinate’ variables to TileDB dimensions,\nmaps NetCDF standard variables to TileDB attributes.\n\n\nconverter2 = tiledb.cf.NetCDF4ConverterEngine.from_file(\n    netcdf_file, coords_to_dims=True, attrs_filters=[tiledb.ZstdFilter(level=7)]\n)\nconverter2\n\n\n# Update properties for the array\nconverter2.get_shared_dim(\"x\").domain = (-5.0, 5.0)\nconverter2.get_shared_dim(\"y\").domain = (-5.0, 5.0)\ndata_array = converter2.get_array_creator(\"array0\")\ndata_array.domain_creator.tiles = (1.0, 1.0)\ndata_array.capacity = 400\nconverter2\n\n\nconverter2.convert_to_array(array_uri)\n\n\ntiledb.ArraySchema.load(array_uri)"
  },
  {
    "objectID": "examples/xarray_engine/tiledb-xarray-partially-filled-arrays.html",
    "href": "examples/xarray_engine/tiledb-xarray-partially-filled-arrays.html",
    "title": "",
    "section": "",
    "text": "This example shows some of the basic usage for opening a TileDB array in xarray using the TileDB backend when the TileDB array is not fully filled.\nThere are two possible values the TileDB-xarray backend can use for a dimension size:\n\n(default) The size of the current non-empty domain when the dataset is first loaded.\nThe size of the full domain of the dimension.\n\nThe default behavior of TileDB is to take the maximum value of all non-empty domains. If you have dimensions with mis-matched domain, the dimension will never return a size larger than the smallest domain.\n\n\n\nThis example requires tiledb-cf to be installed and uses the tiledb, xarray, and numpy libraries.\n\nimport tiledb\nimport xarray as xr\nimport numpy as np\n\n\n# Set names for the output generated by the example.\noutput_dir = \"output/tiledb-xarray-partially-filled\"\narray_uri = f\"{output_dir}/example1\"\ngroup1_uri = f\"{output_dir}/group1\"\ngroup2_uri = f\"{output_dir}/group2\"\n\n\n# Reset output folder\nimport os\nimport shutil\n\nshutil.rmtree(output_dir, ignore_errors=True)\nos.mkdir(output_dir)\n\n\n\n\n\n\n# Create array and write data.\ntiledb.Array.create(\n    array_uri,\n    tiledb.ArraySchema(\n        domain=tiledb.Domain(\n            tiledb.Dim(\"x\", domain=(0, 7), dtype=np.uint64),\n            tiledb.Dim(\"y\", domain=(0, 7), dtype=np.uint64),\n        ),\n        attrs=[tiledb.Attr(\"z\", np.float64)],\n    ),\n)\nwith tiledb.open(array_uri, mode=\"w\") as array:\n    array[0:4, 0:4] = np.reshape(np.arange(16), (4, 4))\n\n\n# Print non-empty domain and data.\nwith tiledb.open(array_uri) as array:\n    print(f\"Non-empty domain: {array.nonempty_domain()}\")\n    print(f\"Data in non-empty domain:\\n {array.multi_index[:, :]['z']}\")\n    print(f\"All data: \\n {array[:, :]['z']}\")\n\n\n# By default, xarray will only open the non-empty domain\nxr.open_dataset(array_uri, engine=\"tiledb\")\n\n\n\n\nWe can create a group that always reads some or all of the dimensions as full dimensions.\n\n# Set `x` to be a fixed-size dimension.\ntiledb.Group.create(group1_uri)\nwith tiledb.Group(group1_uri, mode=\"w\") as group:\n    group.add(uri=array_uri, name=\"z\")\n    group.meta[\"__tiledb_array_fixed_dimensions.z\"] = \"x\"\n\n\nxr.open_dataset(group1_uri, engine=\"tiledb\")\n\n\n# Set `y` to be a fixed-size dimension.\ntiledb.Group.create(group2_uri)\nwith tiledb.Group(group2_uri, mode=\"w\") as group:\n    group.add(uri=array_uri, name=\"z\")\n    group.meta[\"__tiledb_array_fixed_dimensions.z\"] = \"x;y\"\n\n\nxr.open_dataset(group2_uri, engine=\"tiledb\")"
  },
  {
    "objectID": "examples/xarray_engine/tiledb-xarray-basics.html",
    "href": "examples/xarray_engine/tiledb-xarray-basics.html",
    "title": "",
    "section": "",
    "text": "Part 3. Adding additional arrays\nA TileDB group can contain arrays that already exist. We add another array to our TileDB group.\nWe will add a new array to the group that has the same x and y dimensions. Since the array only has 1 TileDB attribute, the xarray backend will use the name of the array rather than the attribute for the variable name.\n\n# Array for z data.\nschema = tiledb.ArraySchema(\n    domain=tiledb.Domain(\n        tiledb.Dim(\"x\", domain=(0, x_size - 1), dtype=np.uint32),\n        tiledb.Dim(\"y\", domain=(0, y_size - 1), dtype=np.uint32),\n    ),\n    attrs=[tiledb.Attr(\"values\", np.float64)],\n)\ntiledb.Array.create(array_uri, schema)\n\n\nwith tiledb.open(array_uri, mode=\"w\") as array:\n    array[:] = z_data\n    array.meta[\"__tiledb_attr.values.description\"] = \"x * exp(-y/2)\"\n\n\n# Add to the group.\nwith tiledb.Group(group_uri, mode=\"w\") as group:\n    group.add(uri=array_uri, name=\"z\", relative=False)\n\n\n# Open the dataset\nxr.open_dataset(group_uri, engine=\"tiledb\")"
  }
]